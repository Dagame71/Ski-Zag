<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <!-- Aggiornato per consentire il ridimensionamento -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Ski Solo – Modified Version</title>
  <style>
    /* Stili di base */
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: "Helvetica Neue", Arial, sans-serif;
      background: #ffffff;
    }
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .container {
      position: relative;
      width: 90%; /* Responsive width */
      max-width: 300px; /* Limita la larghezza massima */
      aspect-ratio: 300 / 520; /* Mantiene il rapporto di aspetto */
      background: #e1dffc url("sfondo.png") no-repeat center center;
      background-size: cover;
      border: 2px solid #ffffff;
      border-radius: 10px;
      margin-top: 20px;
      box-sizing: border-box;
      overflow: hidden;
    }
    canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      cursor: crosshair;
    }
    /* Canvas per la neve */
    #snowCanvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 10;
    }
    /* Bottoni */
    button {
      border: none;
      background: none;
      cursor: pointer;
      font-size: 18px;
      margin: 0;
      padding: 0;
      color: black;
      z-index: 20;
    }
    button:hover { opacity: 0.7; }
    /* Posizionamento bottoni di controllo con percentuali */
    #sameTrack  { position: absolute; bottom: 1.15%; right: 16.67%; }
    #replayButton { position: absolute; bottom: 0.96%; left: 3.33%; }
    #quit { position: absolute; bottom: 1.15%; right: 1.92%; }
    #homeBtn { position: absolute; top: 1.92%; left: 3.33%; }
    #chronoButton { position: absolute; top: 1.92%; right: 3.33%; }
    #viewBtn { position: absolute; bottom: 1.15%; left: 33.33%; transform: translateX(-50%); }
    #saveResultBtn { position: absolute; bottom: 1.15%; left: 17.33%; }
    .info-container {
      margin-top: 13px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    #finalTimeOutput { margin: -10px 0; font-weight: bold; }
    #statusOutput { margin: 15px 0; font-weight: bold; color: red; min-height: 20px; }
    /* Overlay e animazioni */
    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
    .overlay {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background-color: rgba(0,0,0,0.7);
      z-index: 9999;
      display: flex;
      justify-content: center;
      align-items: center;
      animation: fadeIn 0.3s ease;
    }
    .hidden { display: none; }
    .overlay-content {
      background-image: url('backpopup.png');
      background-repeat: no-repeat;
      background-position: center;
      background-size: cover;
      background-color: #fff;
      border-radius: 12px;
      padding: 20px;
      width: 80%; /* Responsive width */
      max-width: 280px;
      box-sizing: border-box;
      position: relative;
      text-align: center;
      color: #333;
      box-shadow: inset 4px 4px 2px rgba(175,219,245,0.8),
                  inset -4px -4px 2px rgba(255,255,255,0.8);
    }
    /* Bottoni per chiudere gli overlay */
    #closeChronoOverlay, #closeViewOverlay, #closeSaveResultOverlay {
      position: absolute;
      top: 10px; left: 10px;
      background-color: #dc3545;
      font-size: 14px;
      padding: 5px 10px;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }
    #closeChronoOverlay:hover, #closeViewOverlay:hover, #closeSaveResultOverlay:hover {
      background-color: #c82333;
    }
    /* Leaderboard */
    .leaderboard-container { display: block; width: 100%; margin-top: 10px; }
    .leaderboard { width: 80%; margin: 0 auto; }
    .leaderboard h2 { text-align: center; margin: 10px 0; }
    ol { border: 1px solid #ccc; border-radius: 5px; list-style: decimal inside; min-height: 100px; padding: 10px; margin: 0; }
    li { padding: 5px 0; }
    /* Stili per il tutorial (slide) */
    .intro-overlay { }
    .slide-content { margin-bottom: 20px; line-height: 1.4; }
    .slide-title { margin-top: 0; margin-bottom: 10px; font-size: 22px; }
    .slides-nav {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 15px;
    }
    .slides-nav .nav-button {
      background: #007bff;
      color: #fff;
      border: none;
      border-radius: 8px;
      padding: 10px 20px; /* Aumentato padding */
      font-size: 16px;    /* Aumentato font-size */
      cursor: pointer;
    }
    .slides-nav .nav-button:disabled { 
      background: #999; 
      cursor: not-allowed; 
    }
    .tutorial-dots { display: flex; justify-content: center; gap: 8px; margin: 10px 0; }
    .dot { width: 10px; height: 10px; border-radius: 50%; background: #ccc; cursor: pointer; transition: background 0.3s; }
    .dot.active { background: #007bff; }
    /* Pulsanti delete per le piste salvate */
    .deleteBtn {
      background-color: #dc3545;
      color: white;
      border: none;
      border-radius: 4px;
      font-size: 12px;
      padding: 2px 4px;
      margin-left: 10px;
      cursor: pointer;
    }
    .deleteBtn:hover {
      background-color: #c82333;
    }
  </style>
</head>
<body>
  <!-- CONTENITORE DI GIOCO -->
  <div class="container" id="gameContainer">
    <canvas id="canvas"></canvas>
    <!-- Canvas per l'effetto neve -->
    <canvas id="snowCanvas" class="hidden"></canvas>
    <!-- Bottoni di controllo -->
    <!-- Il tasto sameTrack ora viene usato per abilitare/disabilitare la neve -->
    <button id="sameTrack" title="Toggle Snow">
      <img src="snowflake.png" alt="Toggle Snow" style="width:19px;height:19px;">
    </button>
    <button id="replayButton" title="Replay">
      <img src="replay.png" alt="Replay" style="width:20px; height:20px;">
    </button>
    <button id="quit" title="New Track">
      <img src="new.png" alt="New Track" style="width:20px;height:20px;">
    </button>
    <!-- Bottone Home aggiunto: puntando a index.html -->
    <button id="homeBtn" title="Home">
      <img src="home.png" alt="Home" style="width:18px;height:18px;">
    </button>
    <button id="chronoButton" title="Top 5">
      <img src="stopwatch.png" alt="Top 5" style="width:20px;height:20px;">
    </button>
    <button id="viewBtn" title="View / Save Track">
      <img src="save.png" alt="View / Save" style="width:17px;height:17px;">
    </button>
    <button id="saveResultBtn" title="Save Result">
      <img src="cup.png" alt="Save Result" style="width:18px;height:18px;">
    </button>
  </div>

  <div class="info-container">
    <p id="finalTimeOutput">⏰1'00"000'''</p>
    <p id="statusOutput"></p>
  </div>

  <!-- OVERLAY TOP 5 -->
  <div id="chronoOverlay" class="overlay hidden">
    <div class="overlay-content">
      <button id="closeChronoOverlay">X</button>
      <div class="leaderboard-container">
        <div class="leaderboard">
          <h2>Top 5</h2>
          <ol id="leaderboardList"></ol>
        </div>
      </div>
    </div>
  </div>

  <!-- OVERLAY View: per salvare e CARICARE le piste -->
  <div id="viewOverlay" class="overlay hidden">
    <div class="overlay-content">
      <button id="closeViewOverlay">X</button>
      <h2>Saved Tracks</h2>
      <div id="savedTracksList"></div>
      <hr>
      <h3>Save current track</h3>
      <input type="text" id="trackNameInput" placeholder="Enter track name">
      <button id="saveTrackBtn">Save Track</button>
    </div>
  </div>

  <!-- OVERLAY Save Result: per salvare il tempo realizzato -->
  <div id="saveResultOverlay" class="overlay hidden">
    <div class="overlay-content">
      <button id="closeSaveResultOverlay">X</button>
      <h2>Save Your Result</h2>
      <input type="text" id="resultNameInput" placeholder="Enter your name">
      <button id="saveResultConfirmBtn">Save Result</button>
    </div>
  </div>

  <!-- OVERLAY TUTORIAL -->
  <div id="tutorialOverlay" class="overlay" style="z-index: 1000;">
    <div class="overlay-content intro-overlay">
      <div id="tutorialContent"></div>
      <div class="tutorial-dots" id="tutorialDots"></div>
      <div class="slides-nav">
        <button class="nav-button" id="tutorialPrev">←</button>
        <button class="nav-button" id="tutorialStart">Start!</button>
        <button class="nav-button" id="tutorialNext">→</button>
      </div>
    </div>
  </div>

  <script>
    /* ==============================================
       VARIABILI GLOBALI E IMPOSTAZIONI
    ============================================== */
    const PATH_LENGTH_SCALING = 500;
    const PENALTY_WEIGHT = 0.5;
    const BORDER_THRESHOLD = 5;
    const hardMode = true; // Abilita collisione con alberi

    // Variabile per il controllo della neve: di default la neve è abilitata
    let snowLocked = false;

    // Variabili per la gestione della neve (come nel campionato)
    let snowIntensity = 0;
    let showSnow = false;
    let weatherState = null;
    function chooseWeatherState(prevState) {
      const r = Math.random() * 100;
      if(r < 60) return "nn";
      else if(r < 80) return "pn";
      else if(r < 95) return "mn";
      else return "nf";
    }
    function applyWeatherState(state) {
      if(state === "nn") { snowIntensity = 0; }
      else if(state === "pn") { snowIntensity = 300; }
      else if(state === "mn") { snowIntensity = 1000; }
      else if(state === "nf") { snowIntensity = 3250;}
      showSnow = (snowIntensity > 0);
      return showSnow;
    }

    let canvas = document.getElementById('canvas');
    let ctx = canvas.getContext('2d');
    let snowCanvas = document.getElementById('snowCanvas');
    let snowCtx = snowCanvas.getContext('2d');
    let finalTimeOutput = document.getElementById('finalTimeOutput');
    let statusOutput = document.getElementById('statusOutput');

    let sameTrackButton = document.getElementById('sameTrack');
    let replayButton = document.getElementById('replayButton');
    let quitButton = document.getElementById('quit');
    let homeBtn = document.getElementById('homeBtn'); // Il nuovo pulsante Home
    let chronoButton = document.getElementById('chronoButton');
    let viewBtn = document.getElementById('viewBtn');
    let saveResultBtn = document.getElementById('saveResultBtn');

    let chronoOverlay = document.getElementById('chronoOverlay');
    let closeChronoOverlay = document.getElementById('closeChronoOverlay');
    let viewOverlay = document.getElementById('viewOverlay');
    let closeViewOverlay = document.getElementById('closeViewOverlay');
    let saveResultOverlay = document.getElementById('saveResultOverlay');
    let closeSaveResultOverlay = document.getElementById('closeSaveResultOverlay');

    let tutorialOverlay = document.getElementById('tutorialOverlay');
    let tutorialContent = document.getElementById('tutorialContent');
    let tutorialDots = document.getElementById('tutorialDots');
    let tutorialPrev = document.getElementById('tutorialPrev');
    let tutorialNext = document.getElementById('tutorialNext');
    let tutorialStart = document.getElementById('tutorialStart');

    // Variabili di gioco
    let currentTrack = null;     // { gates, trees }
    let bestTimes = [];          // Array dei migliori tempi della pista corrente
    // Saved tracks saranno salvate in localStorage
    let savedTracks = {};
    // Variabile per ricordare il nome della pista corrente (se salvata)
    let currentTrackName = "";
    // Variabile per salvare il tempo finale appena calcolato
    window.lastFinalTime = 0;
    let gates = [];
    let trees = [];
    let pointsPath = [];
    let drawing = false;
    let startTime = 0;
    let lastCompleteRun = null;
    let outPenaltyCount = 0;
    let isOut = false;
    let falseStartCount = 0;
    let intersectedGates = new Set();  // Insieme degli indici delle porte attraversate

    // Punto di partenza ed area di arrivo
    let startPoint = { x: 150, y: 30 };
    let finishRect = { x: 130, y: 490, width: 40, height: 10 };
    let globalWind = Math.random() * 1 - 0.5;

    // Slides del tutorial
    let tutorialSlides = [
      { title: "Welcome to Ski Solo!", content: "This is a single-player ski game.<br>Start at the house and ski to the finish." },
      { title: "How to Play", content: "Draw your path starting from the house icon. Pass through all gates and finish at the finish area. Avoid trees and boundaries." },
      { title: "Controls", content: "Buttons:<br>🔁 Toggle Snow<br>⏯️ Replay (review run)<br>❌ New Track<br>⏱️ Top 5 (view best times)<br>👁️ View (save/load track)<br>🏆 Cup (save your result)" },
      { title: "Good Luck!", content: "Try to beat your best time! Enjoy the slope!" }
    ];
    let currentTutorialIndex = 0;

    const container = document.getElementById('gameContainer'); // Per il ridimensionamento

    function resizeCanvas(){
      canvas.width = container.clientWidth;
      canvas.height = container.clientHeight;
      snowCanvas.width = container.clientWidth;
      snowCanvas.height = container.clientHeight;

      // Aggiorna i punti di partenza e di arrivo in base alle nuove dimensioni
      startPoint = { x: canvas.width / 2, y: 30 / 520 * canvas.height };
      finishRect = { 
        x: (canvas.width / 2) - (40 / 300 * canvas.width) / 2, 
        y: canvas.height - (30 / 520 * canvas.height), 
        width: 40 / 300 * canvas.width, 
        height: 10 / 520 * canvas.height 
      };

      // Ridisegna la pista e gli elementi
      drawTrack(currentTrack);
    }
    // Rimuovi la chiamata iniziale a resizeCanvas() qui
    // resizeCanvas();

    function clearCanvas(){ ctx.clearRect(0,0,canvas.width, canvas.height); }

    function drawStartPoint(){
      ctx.font = `${18 / 520 * canvas.height}px Arial`; // Font relativo
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('🏠', startPoint.x, startPoint.y);
    }
    function drawFinishArea(){
      const { x, y, width, height } = finishRect;
      const sq = width / 8;
      let rowCount = Math.floor(height / (width / 8));
      for(let row=0; row<rowCount; row++){
        for(let col=0; col<8; col++){
          ctx.fillStyle = ((row+col)%2===0) ? 'black' : '#F0F0F0';
          ctx.fillRect(x+col*sq, y+row*sq, sq, sq);
        }
      }
    }
    // Icone per i gate
    const gateIcons = {
      red: new Image(),
      blue: new Image()
    };
    gateIcons.red.src = "red_gate.svg";
    gateIcons.blue.src = "blue_gate.svg";

    function generateGates(count){
      let startWithRed = (Math.random() < 0.5);
      let isRed = startWithRed;
      let arr = [];
      for(let i=0; i<count; i++){
        let dir = isRed ? 1 : -1;
        let x = isRed 
          ? Math.random()*(canvas.width/2-35)+canvas.width/2
          : Math.random()*(canvas.width/2-35)+35;
        let y = 60 / 520 * canvas.height + i*((canvas.height - (120 / 520 * canvas.height))/count);
        let color = isRed ? 'red' : 'blue';
        arr.push({
          x, y, color,
          line: { x1: x, y1: y, x2: x + dir * (200 / 300 * canvas.width), y2: y }
        });
        isRed = !isRed;
      }
      return arr;
    }
    function generateTrees(gArr){
      let treeCount = Math.floor(Math.random()*3)+6;
      let arr = [];
      const margin = 15 / 520 * canvas.height, 
            minGate = 50 / 300 * canvas.width, 
            minTree = 30 / 520 * canvas.height, 
            minFinish = 50 / 300 * canvas.width, 
            minStart = 20 / 520 * canvas.height, 
            minTop = 30 / 520 * canvas.height;
      while(arr.length < treeCount){
        let tx = margin + Math.random()*(canvas.width-2*margin);
        let ty = 20 / 520 * canvas.height + Math.random()*(canvas.height - (20 / 520 * canvas.height) - margin);
        let closeGate = gArr.some(g=> Math.hypot(tx-g.x, ty-g.y) < minGate);
        let closeTrees = arr.some(t=> Math.hypot(tx-t.x, ty-t.y) < minTree);
        let closeFinish = isNearFinish(tx,ty,finishRect,minFinish);
        let closeStart = Math.hypot(tx-startPoint.x, ty-startPoint.y) < minStart;
        if(!closeGate && !closeTrees && !closeFinish && !closeStart){
          arr.push({ x: tx, y: ty });
        }
      }
      return arr;
    }
    function createTrack(){
      let g = generateGates(8);
      let t = generateTrees(g);
      return { gates: g, trees: t };
    }
    function drawGates(gArr){
      gArr.forEach(g=>{
        let icon = g.color==="red" ? gateIcons.red : gateIcons.blue;
        let iconWidth = 16 / 300 * canvas.width; // Dimensione relativa
        let iconHeight = 16 / 520 * canvas.height;
        ctx.drawImage(icon, g.x - iconWidth / 2, g.y - iconHeight / 2, iconWidth, iconHeight);
      });
    }
    function drawTrees(tArr){
      let treeImg = new Image();
      treeImg.src = "./tree.svg";
      treeImg.onload = ()=>{
        tArr.forEach(t=>{
          let treeWidth = 12 / 300 * canvas.width;
          let treeHeight = 20 / 520 * canvas.height;
          ctx.drawImage(treeImg, t.x - treeWidth / 2, t.y - treeHeight, treeWidth, treeHeight);
        });
      };
    }
    function drawTrack(track){
      clearCanvas();
      gates = track.gates;
      trees = track.trees;
      intersectedGates = new Set();
      drawStartPoint();
      drawFinishArea();
      drawGates(gates);
      drawTrees(trees);
    }

    // (Opzionale) Effetto neve – come nel campionato
    let snowflakes = [];
    function initSnow(){
      snowflakes = [];
      for(let i=0; i<snowIntensity; i++){
        snowflakes.push({
          x: Math.random()*snowCanvas.width,
          y: Math.random()*snowCanvas.height,
          radius: Math.random()*3+1,
          speedY: Math.random()*0.5+0.5,
          speedX: Math.random()*0.5-0.25
        });
      }
    }
    function updateSnow(){
      if(!showSnow)return;
      snowCtx.clearRect(0,0,snowCanvas.width,snowCanvas.height);
      snowflakes.forEach(flake=>{
        flake.x += flake.speedX + globalWind;
        flake.y += flake.speedY;
        if(flake.y > snowCanvas.height){
          flake.y = 0;
          flake.x = Math.random()*snowCanvas.width;
        }
        if(flake.x > snowCanvas.width) flake.x = 0;
        if(flake.x < 0) flake.x = snowCanvas.width;
        snowCtx.beginPath();
        snowCtx.arc(flake.x, flake.y, flake.radius, 0, Math.PI*2);
        snowCtx.fillStyle = 'white';
        snowCtx.fill();
      });
      requestAnimationFrame(updateSnow);
    }

    // ------------------------------------------------------------------
    // GESTIONE EVENTI MOUSE / TOUCH PER IL TRACCIARE IL PERCORSO
    // ------------------------------------------------------------------
    if(!canvas._eventsAttached){
      canvas.addEventListener('mousedown', handleMouseDown);
      canvas.addEventListener('mousemove', handleMouseMove);
      canvas.addEventListener('mouseup', handleMouseUp);
      canvas.addEventListener('touchstart', handleTouchStart);
      canvas.addEventListener('touchmove', handleTouchMove);
      canvas.addEventListener('touchend', handleTouchEnd);
      canvas._eventsAttached = true;
    }
    function getMouseCoords(e){
      let rect = canvas.getBoundingClientRect();
      let cx = e.touches ? e.touches[0].clientX : e.clientX;
      let cy = e.touches ? e.touches[0].clientY : e.clientY;
      return { x: (cx - rect.left) / rect.width * canvas.width, y: (cy - rect.top) / rect.height * canvas.height };
    }
    function isNearStartPoint(x,y){ return (Math.hypot(x - startPoint.x, y - startPoint.y) <= 20 / 520 * canvas.height); }

    // ------------------------------------------------------------------
    // GESTIONE FALSE START CON MESSAGGI ORIGINALI
    // ------------------------------------------------------------------
    function handleMouseDown(e){
      let {x,y} = getMouseCoords(e);
      if(!isNearStartPoint(x,y)){
        falseStartCount++;
        if(falseStartCount===1){
          statusOutput.innerHTML = '<span style="color:red;">False start!</span> <span style="color:black;">2nd attempt!</span>';
          setTimeout(()=>{ restoreStatusOutput(); }, 1000);
        } else if(falseStartCount===2){
          statusOutput.innerHTML = '<span style="color:red;">False start!</span> <span style="color:black;">Last attempt!</span>';
          setTimeout(()=>{ restoreStatusOutput(); }, 1000);
        } else if(falseStartCount>=3){
          statusOutput.textContent = 'Run failed due to consecutive false starts!';
          failRun("Run failed due to false starts.");
          falseStartCount = 0;
        }
        return;
      }
      falseStartCount = 0;
      outPenaltyCount = 0;
      isOut = false;
      drawing = true;
      pointsPath = [];
      startTime = performance.now();
      statusOutput.textContent = "";
      ctx.beginPath();
      pointsPath.push({ x, y, t: 0 });
      ctx.moveTo(x,y);
    }
    function handleMouseMove(e){
      if(!drawing)return;
      let {x,y} = getMouseCoords(e);
      let p1 = pointsPath[pointsPath.length-1];
      let p2 = { x, y };
      if(p1 && checkInterpolationForBorder(p1,p2)){
        if(!isOut){ outPenaltyCount++; isOut = true; }
      } else { isOut = false; }
      let now = performance.now() - startTime;
      pointsPath.push({ x, y, t: now });
      ctx.lineTo(x,y);
      ctx.strokeStyle = '#a4b8eb';
      ctx.lineWidth = 2 / 520 * canvas.height; // Line width relativo
      ctx.stroke();
      checkIntersections();
    }
    function handleMouseUp(e){
      if(!drawing)return;
      drawing = false;
      if(!didFinishOrFail){ failRun("Run interrupted!"); }
    }
    function handleTouchStart(e){
      e.preventDefault();
      let {x,y} = getMouseCoords(e);
      if(!isNearStartPoint(x,y)){
        statusOutput.textContent = "You must start from the house icon!";
        return;
      }
      falseStartCount = 0;
      outPenaltyCount = 0;
      isOut = false;
      drawing = true;
      pointsPath = [];
      startTime = performance.now();
      statusOutput.textContent = "";
      ctx.beginPath();
      pointsPath.push({ x, y, t: 0 });
      ctx.moveTo(x,y);
    }
    function handleTouchMove(e){
      e.preventDefault();
      if(!drawing)return;
      let {x,y} = getMouseCoords(e);
      let p1 = pointsPath[pointsPath.length-1];
      let p2 = { x, y };
      if(p1 && checkInterpolationForBorder(p1, p2)){
        if(!isOut){ outPenaltyCount++; isOut = true; }
      } else { isOut = false; }
      let now = performance.now() - startTime;
      pointsPath.push({ x, y, t: now });
      ctx.lineTo(x,y);
      ctx.strokeStyle = '#a4b8eb';
      ctx.lineWidth = 2 / 520 * canvas.height; // Line width relativo
      ctx.stroke();
      checkIntersections();
    }
    function handleTouchEnd(e){
      e.preventDefault();
      if(!drawing)return;
      drawing = false;
      if(!didFinishOrFail){ failRun("Run interrupted!"); }
    }
    function checkInterpolationForBorder(p1, p2){
      const stepLength = 2 / 520 * canvas.height; // Step relativo
      const dx = p2.x - p1.x, dy = p2.y - p1.y;
      const distance = Math.hypot(dx,dy);
      const steps = Math.ceil(distance/stepLength);
      for(let i=1; i<=steps; i++){
        let t = i/steps;
        let ix = p1.x + t*dx;
        let iy = p1.y + t*dy;
        if(ix < BORDER_THRESHOLD / 300 * canvas.width || ix > canvas.width - BORDER_THRESHOLD / 300 * canvas.width ||
           iy < BORDER_THRESHOLD / 520 * canvas.height || iy > canvas.height - BORDER_THRESHOLD / 520 * canvas.height){
          return true;
        }
      }
      return false;
    }

    // Flag per terminazione o fallimento della run
    let didFinishOrFail = false;

    // ------------------------------------------------------------------
    // CHECK INTERSECTIONS: Alberi, Porte e Traguardo
    // ------------------------------------------------------------------
    function checkIntersections(){
      for(let i=1; i<pointsPath.length; i++){
        let p1 = pointsPath[i-1], p2 = pointsPath[i];
        // Collisione con alberi (come nella versione campionato)
        if(hardMode){
          for(const tree of trees){
            let steps = Math.ceil(Math.hypot(p2.x-p1.x, p2.y-p1.y)/5);
            for(let j=0; j<=steps; j++){
              let ix = p1.x + (p2.x-p1.x)*(j/steps);
              let iy = p1.y + (p2.y-p1.y)*(j/steps);
              // Centro visivo dell'albero: (tree.x, tree.y-10 / 520 * canvas.height)
              let dist = Math.hypot(ix - tree.x, iy - (tree.y - 10 / 520 * canvas.height));
              if(dist < 10 / 520 * canvas.height){
                didFinishOrFail = true;
                failRun("You hit a tree!");
                return;
              }
            }
          }
        }
        // Controllo porte
        for(const [idx, gate] of gates.entries()){
          if(linesIntersect(p1.x, p1.y, p2.x, p2.y, gate.line.x1, gate.line.y1, gate.line.x2, gate.line.y2)){
            intersectedGates.add(idx);
          }
        }
        // Controllo traguardo: la run termina appena il segmento interseca l'area di finish
        if(isSegmentInFinishArea(p1, p2, finishRect)){
          didFinishOrFail = true;
          if(intersectedGates.size === gates.length){
            finishRun();
          } else {
            failRun("You missed a gate!");
          }
          return;
        }
      }
    }
    function linesIntersect(x1,y1,x2,y2,x3,y3,x4,y4){
      const det = (x2-x1)*(y4-y3) - (y2-y1)*(x4-x3);
      if(det===0)return false;
      const lambda = ((y4-y3)*(x4-x1)+(x3-x4)*(y4-y1))/det;
      const gamma  = ((y1-y2)*(x4-x1)+(x2-x1)*(y4-y1))/det;
      return (lambda>=0 && lambda<=1 && gamma>=0 && gamma<=1);
    }
    function isSegmentInFinishArea(p1, p2, rect){
      if((p1.y < rect.y && p2.y < rect.y) || (p1.y > rect.y+rect.height && p2.y > rect.y+rect.height))
        return false;
      if((p1.x < rect.x && p2.x < rect.x) || (p1.x > rect.x+rect.width && p2.x > rect.x+rect.width))
        return false;
      return true;
    }
    function isNearFinish(x, y, rect, minD){
      return ( x>= rect.x-minD && x<= rect.x+rect.width+minD &&
               y>= rect.y-minD && y<= rect.y+rect.height+minD );
    }

    // ------------------------------------------------------------------
    // FINISH RUN / FAIL RUN CON RESET AUTOMATICO (dopo 2 secondi)
    // ------------------------------------------------------------------
    function finishRun(){
      drawing = false;
      didFinishOrFail = true;
      let endTime = performance.now();
      let elapsedTime = endTime - startTime;
      let distPx = calculateDistance(pointsPath);
      let baseTime = calculateFinalTime(elapsedTime, distPx);
      let outPenaltyTotal = outPenaltyCount * 0.10;
      let finalTime = baseTime + outPenaltyTotal;
      finalTimeOutput.textContent = `⏰ ${formatTime(finalTime)}${(outPenaltyTotal>0)?` (+${outPenaltyTotal.toFixed(2)})`:""}`;
      statusOutput.textContent = "Finished!";
      lastCompleteRun = JSON.parse(JSON.stringify(pointsPath));
      updateBestTimes(finalTime, lastCompleteRun);
      // Salva il tempo finale in una variabile globale
      window.lastFinalTime = finalTime;
      // Se la pista corrente è stata salvata, aggiorniamo i record in localStorage
      if(currentTrackName !== ""){
        savedTracks[currentTrackName].bestTimes = bestTimes;
        storeSavedTracks();
      }
      // Dopo 2 secondi reset della pista
      setTimeout(()=>{ resetRun(); }, 2000);
    }
    function failRun(msg){
      drawing = false;
      didFinishOrFail = true;
      statusOutput.textContent = msg;
      lastCompleteRun = JSON.parse(JSON.stringify(pointsPath));
      // Dopo 2 secondi reset della pista
      setTimeout(()=>{ resetRun(); }, 2000);
    }
    function calculateDistance(arr){
      let tot = 0;
      for(let i=1; i<arr.length; i++){
        let dx = arr[i].x - arr[i-1].x;
        let dy = arr[i].y - arr[i-1].y;
        tot += Math.hypot(dx, dy);
      }
      return tot;
    }
    function calculateFinalTime(ms, dist){
      let s = ms/1000;
      let penalty = PENALTY_WEIGHT * (dist / PATH_LENGTH_SCALING);
      return 60 + s + penalty;
    }
    function formatTime(sec){
      let m = Math.floor(sec/60);
      let r = (sec % 60).toFixed(3);
      return `${m}'${r.replace('.', '"')}'''`;
    }
    function updateBestTimes(time, replayData){
      let result = { name: "Anonymous", time, replay: replayData };
      bestTimes.push(result);
      bestTimes.sort((a,b)=> a.time - b.time);
      if(bestTimes.length>5) bestTimes.length = 5;
    }
    function replayTrajectory(customPoints){
      let rp = (customPoints && customPoints.length>=2) ? customPoints : pointsPath;
      if(!rp || rp.length<2){
        statusOutput.textContent = "No run to replay!";
        setTimeout(()=>{ statusOutput.textContent = ""; }, 1000);
        return;
      }
      clearCanvas();
      drawStartPoint();
      drawFinishArea();
      drawGates(gates);
      drawTrees(trees);
      let i = 0;
      function step(){
        if(i>=rp.length-1){
          setTimeout(()=>{
            clearCanvas();
            drawTrack(currentTrack);
            statusOutput.textContent = "";
          },500);
          return;
        }
        ctx.beginPath();
        ctx.moveTo(rp[i].x, rp[i].y);
        ctx.lineTo(rp[i+1].x, rp[i+1].y);
        ctx.strokeStyle = '#a4b8eb';
        ctx.lineWidth = 2 / 520 * canvas.height; // Line width relativo
        ctx.stroke();
        let dt = rp[i+1].t - rp[i].t;
        i++;
        setTimeout(step, dt);
      }
      setTimeout(step, 0);
    }
    function restoreStatusOutput(){ statusOutput.textContent = "Play Ski Solo"; }

    // ------------------------------------------------------------------
    // GESTIONE BOTTONI (Modalità solitario)
    // ------------------------------------------------------------------

    // Modifica del tasto SAME TRACK: ora il tasto inverte il flag snowLocked,
    // cambia leggermente l'opacità del bottone e mostra un breve messaggio nello status
    sameTrackButton.addEventListener('click', ()=> { 
      snowLocked = !snowLocked;
      if(snowLocked){
        sameTrackButton.style.opacity = "0.5";  
        statusOutput.textContent = "Snow locked";
      } else {
        sameTrackButton.style.opacity = "1";    
        statusOutput.textContent = "Snow enabled";
      }
      setTimeout(restoreStatusOutput, 1000);
      resetRun();
    });

    replayButton.addEventListener('click', ()=>{
      if(lastCompleteRun && lastCompleteRun.length>=2){
        replayTrajectory(lastCompleteRun);
      } else {
        statusOutput.textContent = "No run to replay!";
        setTimeout(()=>{ statusOutput.textContent = ""; }, 1000);
      }
    });
    quitButton.addEventListener('click', ()=>{
      // Genera una nuova pista: se la pista cambia, resetta anche il replay
      currentTrack = createTrack();
      bestTimes = [];
      currentTrackName = ""; // Azzeriamo il nome se si genera una nuova pista
      lastCompleteRun = null; // Resettiamo il replay perché la pista è cambiata
      resetRun();
      drawTrack(currentTrack);
    });
    chronoButton.addEventListener('click', ()=>{
      updateLeaderboard();
      chronoOverlay.classList.remove('hidden');
    });
    closeChronoOverlay.addEventListener('click', ()=>{ chronoOverlay.classList.add('hidden'); });
    viewBtn.addEventListener('click', ()=>{
      updateSavedTracksList();
      viewOverlay.classList.remove('hidden');
    });
    closeViewOverlay.addEventListener('click', ()=>{ viewOverlay.classList.add('hidden'); });
    saveResultBtn.addEventListener('click', ()=>{ saveResultOverlay.classList.remove('hidden'); });
    closeSaveResultOverlay.addEventListener('click', ()=>{ saveResultOverlay.classList.add('hidden'); });
    // Salvataggio del risultato: se esiste già un record "Anonymous" con lo stesso final time, ne aggiorna il nome
    document.getElementById('saveResultConfirmBtn').addEventListener('click', ()=>{
      let name = document.getElementById('resultNameInput').value.trim();
      if(name===""){
        alert("Please enter a name.");
        return;
      }
      if(typeof window.lastFinalTime !== 'number' || window.lastFinalTime === 0){
        alert("No valid final time recorded!");
        return;
      }
      let found = bestTimes.find(item => item.name === "Anonymous" && item.time === window.lastFinalTime);
      if(found){
        found.name = name;
      } else {
        bestTimes.push({ name, time: window.lastFinalTime, replay: lastCompleteRun });
      }
      bestTimes.sort((a,b)=> a.time - b.time);
      if(bestTimes.length>5) bestTimes.length = 5;
      saveResultOverlay.classList.add('hidden');
      updateLeaderboard();
    });
    function resetRun(){
      drawing = false;
      didFinishOrFail = false;
      pointsPath = [];
      statusOutput.textContent = "";
      finalTimeOutput.textContent = `⏰1'00"000'''`;
      clearCanvas();
      drawTrack(currentTrack);
      // Aggiorna il vento: assegna un nuovo valore casuale ad ogni reset
      globalWind = Math.random() * 1 - 0.5;
      // Gestione neve: seleziona meteo e, se previsto, attiva l’effetto
      weatherState = chooseWeatherState(weatherState);
      applyWeatherState(weatherState);
      // Se la neve è bloccata, nascondi il canvas della neve
      if(snowLocked){
        snowCanvas.classList.add('hidden');
      } else {
        if(showSnow){
          snowCanvas.classList.remove('hidden');
          initSnow();
          updateSnow();
        } else {
          snowCanvas.classList.add('hidden');
        }
      }
    }
    function updateLeaderboard(){
      let lb = document.getElementById('leaderboardList');
      lb.innerHTML = "";
      bestTimes.forEach((entry, i)=>{
        let li = document.createElement('li');
        if(i===0){
          li.innerHTML = `${entry.name} - ${formatTime(entry.time)} <span style="font-size:18px; cursor:pointer;" title="Click to watch the best replay">⏯️</span>`;
          li.style.fontWeight = 'bold';
          li.addEventListener('click', ()=>{
            chronoOverlay.classList.add('hidden');
            replayTrajectory(entry.replay);
          });
        } else {
          li.textContent = `${entry.name} - ${formatTime(entry.time)}`;
        }
        lb.appendChild(li);
      });
    }

    // ------------------------------------------------------------------
    // GESTIONE TRACK SAVE E CARICAMENTO (localStorage)
    // ------------------------------------------------------------------
    const LS_KEY = "skiSolo_savedTracks";
    function loadSavedTracks() {
      let saved = localStorage.getItem(LS_KEY);
      if(saved) {
        try {
          savedTracks = JSON.parse(saved);
        } catch(e) {
          savedTracks = {};
        }
      } else {
        savedTracks = {};
      }
    }
    function storeSavedTracks() {
      localStorage.setItem(LS_KEY, JSON.stringify(savedTracks));
    }
    // Aggiorna la lista del popup (con possibilità di cancellazione)
    function updateSavedTracksList(){
      loadSavedTracks();
      let listDiv = document.getElementById('savedTracksList');
      listDiv.innerHTML = "";
      for(let name in savedTracks){
        let container = document.createElement('div');
        container.style.display = "flex";
        container.style.alignItems = "center";
        container.style.justifyContent = "space-between";
        container.style.margin = "5px 0";
        let span = document.createElement('span');
        span.textContent = name;
        span.style.cursor = "pointer";
        span.addEventListener('click', ()=>{
          let saved = savedTracks[name];
          currentTrack = saved.track;
          bestTimes = saved.bestTimes || [];
          currentTrackName = name;
          resizeCanvas(); // Ridimensiona il canvas dopo aver caricato la nuova pista
          resetRun();
          viewOverlay.classList.add('hidden');
        });
        let delBtn = document.createElement('button');
        delBtn.textContent = "Delete";
        delBtn.className = "deleteBtn";
        delBtn.addEventListener('click', ()=>{
          if(confirm(`Are you sure you want to delete the track "${name}"?`)){
            delete savedTracks[name];
            storeSavedTracks();
            updateSavedTracksList();
          }
        });
        container.appendChild(span);
        container.appendChild(delBtn);
        listDiv.appendChild(container);
      }
    }
    document.getElementById('saveTrackBtn').addEventListener('click', ()=>{
      let trackName = document.getElementById('trackNameInput').value.trim();
      if(trackName===""){
        alert("Enter a track name.");
        return;
      }
      savedTracks[trackName] = { track: currentTrack, bestTimes: [...bestTimes] };
      currentTrackName = trackName;
      storeSavedTracks();
      alert("Track saved!");
      updateSavedTracksList();
      viewOverlay.classList.add('hidden'); // Chiude il popup automaticamente
    });

    // ------------------------------------------------------------------
    // TUTORIAL (Overlay iniziale)
    // ------------------------------------------------------------------
    function renderTutorial(){
      let slide = tutorialSlides[currentTutorialIndex];
      tutorialContent.innerHTML = `<h2>${slide.title}</h2><p>${slide.content}</p>`;
      tutorialDots.innerHTML = "";
      
      tutorialSlides.forEach((s, i) => {
        let d = document.createElement('div');
        d.className = "dot" + (i === currentTutorialIndex ? " active" : "");
        d.addEventListener('click', () => {
          currentTutorialIndex = i;
          renderTutorial();
        });
        tutorialDots.appendChild(d);
      });
      
      // Mantieni sempre visibile il pulsante "Start"
      tutorialStart.style.display = "inline-block";
      
      // Mantieni sempre visibile le frecce "Prev" e "Next"
      tutorialPrev.style.display = "inline-block";
      tutorialNext.style.display = "inline-block";
    }
    tutorialPrev.addEventListener('click', ()=>{
      if(currentTutorialIndex > 0){
        currentTutorialIndex--;
        renderTutorial();
      }
    });
    tutorialNext.addEventListener('click', ()=>{
      if(currentTutorialIndex < tutorialSlides.length -1){
        currentTutorialIndex++;
        renderTutorial();
      }
    });
    tutorialStart.addEventListener('click', ()=>{
      tutorialOverlay.classList.add('hidden');
      startGame();
    });
    function startGame(){
      loadSavedTracks();
      currentTrack = createTrack();
      bestTimes = [];
      currentTrackName = "";
      resizeCanvas(); // Chiama la funzione di ridimensionamento
      resetRun();
      drawTrack(currentTrack);
    }
    renderTutorial();
    // Il tutorial viene mostrato all'avvio

    // Aggiunta dell'event listener per il pulsante Home (già presente nel codice)
    document.getElementById('homeBtn').addEventListener('click', function() {
      if (confirm('Are you sure you want to quit?')) { 
        location.href = 'index.html';
      }
    });

    // Inizializza il canvas al caricamento
    window.onload = function() {
      resizeCanvas();
    };
  </script>
</body>
</html>
