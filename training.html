<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Ski Solo ‚Äì Responsive Version</title>
  <style>

    /* Stili di base */
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: "Helvetica Neue", Arial, sans-serif;
      background: #c4d3fc;
 margin-top: 10px;
    }
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .container {
      position: relative;
      width: 90%; /* Responsive width */
      max-width: 90vw; /* 90% della larghezza della viewport */
      aspect-ratio: 300 / 520; /* Mantiene il rapporto di aspetto */
      background: #e1dffc url("sfondo.png") no-repeat center center;
      background-size: cover;
      border: 0px solid #ffffff;
      border-radius: 10px;
      margin-top: 20px;
      box-sizing: border-box;
      overflow: hidden;
    }
    canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      cursor: crosshair;
    }
    /* Canvas per la neve */
#snowCanvas {
  position: fixed;     /* per coprire tutto lo schermo */
  top: 0;
  left: 0;
  width: 100vw;        /* copre l'intera larghezza finestra */
  height: 100vh;       /* copre l'intera altezza finestra */
  pointer-events: none;/* la neve non intercetta clic/touch */
  z-index: 5;          /* layer medio */
}
    /* Bottoni */
    button {
      border: none;
      background: none;
      cursor: pointer;
      font-size: 18px;
      margin: 0;
      padding: 0;
      color: black;
      z-index: 9999;
    }
    button:hover { opacity: 0.7; }
.button-disabled {
  background-color: transparent; 
  border: 0px solid #aaa; /* Bordo scuro per simulare effetto premuto */
  color: transparent; /* Colore del testo */
  cursor: not-allowed; /* Cambia il cursore */
  opacity: 0.7; /* Rende il pulsante meno evidente */
}
.button-disabled:hover {
  opacity: 0.7; /* Hover non cambia l'aspetto */
}
.play-button {
  display: block;
  margin: 20px auto 0; /* Sposta il pulsante verso il basso e lo centra */
  background-color: #8fa2f7; /* Colore del pulsante */
  font-size: 16px;
  padding: 10px 20px;
  color: white;
  border: none;
  border-radius: 5px;
  cursor: pointer;
  text-align: center;
}

.play-button:hover {
  background-color: #bdc9fb; /* Colore hover */
}

    /* Posizionamento bottoni di controllo con percentuali */
    #sameTrack  { position: absolute; bottom: 1.15%; right: 16.67%; }
    #replayButton { position: absolute; bottom: 0.96%; left: 3.33%; }
    #quit { position: absolute; bottom: 1.15%; right: 1.92%; }
    #homeBtn { position: absolute; top: 1.92%; left: 3.33%; }
    #chronoButton { position: absolute; top: 1.92%; right: 3.33%; }
    #viewBtn { position: absolute; bottom: 1.15%; left: 33.33%; transform: translateX(-50%); }
    #saveResultBtn { position: absolute; bottom: 1.15%; left: 17.33%; }
#challengeButton {
  position: absolute;
  bottom: 5%;
  right: 44%;
  background: none;
  border: none;
  font-size: 24px;
  cursor: pointer;
  z-index: 9999;
}
#challengeButton:hover {
  opacity: 0.7;
}


    /* Contenitore delle info */
    .info-container {
      margin-top: -10px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
  position: relative;
  z-index: 9999; /* sopra la neve */
    }

    /* UNICO PARAGRAFO per final time + messaggi */
    #infoLine {
      margin: 10px 0;
      font-weight: bold;
      font-size: 1.2em; /* dimensione unificata, puoi variare */
      min-height: 20px; 
      text-align: center;
      color: black; 
    }

    /* Overlay e animazioni */
    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
    .overlay {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background-color: rgba(0,0,0,0.7);
      z-index: 9999;
      display: flex;
      justify-content: center;
      align-items: center;
      animation: fadeIn 0.3s ease;
    }

    @keyframes blink {
      0%, 100% { opacity: 1; }
      50%      { opacity: 0; }
    }
    .record {
      animation: blink 0.5s ease-in-out 3;
    }

    .hidden { display: none; }
    .overlay-content {
      background-image: url('backpopup.png');
      background-repeat: no-repeat;
      background-position: center;
      background-size: cover;
      background-color: #fff;
      border-radius: 12px;
      padding: 20px;
      width: 80%; /* Responsive width */
      max-width: 280px;
      box-sizing: border-box;
      position: relative;
      text-align: center;
      color: #333;
      box-shadow: inset 4px 4px 2px rgba(175,219,245,0.8),
                  inset -4px -4px 2px rgba(255,255,255,0.8);
    }
    /* Bottoni per chiudere gli overlay */
    #closeChronoOverlay, #closeViewOverlay, #closeSaveResultOverlay {
      position: absolute;
      top: 10px; left: 10px;
      background-color: #8fa2f7;
      font-size: 14px;
      padding: 5px 10px;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }
    #closeChronoOverlay:hover, #closeViewOverlay:hover, #closeSaveResultOverlay:hover {
      background-color: #bdc9fb;
    }
    /* Leaderboard */
    .leaderboard-container { display: block; width: 100%; margin-top: 10px; }
    .leaderboard { width: 80%; margin: 0 auto; }
    .leaderboard h2 { text-align: center; margin: 10px 0; }
    ol { border: 1px solid #999bf2; border-radius: 5px; list-style: decimal inside; min-height: 100px; padding: 10px; margin: 0; }
    li { padding: 5px 0; }
    /* Stili per il tutorial (slide) */
    .intro-overlay { }
    .slide-content { margin-bottom: 20px; line-height: 1.4; }
    .slide-title { margin-top: 0; margin-bottom: 10px; font-size: 22px; }
    .slides-nav {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 15px;
    }
    .slides-nav .nav-button {
      background: #007bff;
      color: #fff;
      border: none;
      border-radius: 8px;
      padding: 10px 20px; /* Aumentato padding */
      font-size: 16px;    /* Aumentato font-size */
      cursor: pointer;
    }
    .slides-nav .nav-button:disabled { 
      background: #999; 
      cursor: not-allowed; 
    }
    .tutorial-dots { display: flex; justify-content: center; gap: 8px; margin: 10px 0; }
    .dot { width: 10px; height: 10px; border-radius: 50%; background: #ccc; cursor: pointer; transition: background 0.3s; }
    .dot.active { background: #007bff; }

    /* Pulsanti delete per le piste salvate */
    .deleteBtn {
      background-color: #999bf2;
      color: white;
      border: none;
      border-radius: 4px;
      font-size: 12px;
      padding: 2px 4px;
      margin-left: 10px;
      cursor: pointer;
    }
    .deleteBtn:hover {
      background-color: #cbcdf9;
    }

    @media (min-width: 768px) {
      .container {
        max-width: 500px !important; 
      }
    }
  </style>
</head>
<body>
<!-- Canvas NEVE a pagina intera -->
<canvas id="snowCanvas" class="hidden"></canvas>
  <!-- CONTENITORE DI GIOCO -->
  <div class="container" id="gameContainer">
    <canvas id="canvas"></canvas>
    <!-- Canvas per l'effetto neve -->
    <!-- Bottoni di controllo -->
    <!-- Il tasto sameTrack ora viene usato per abilitare/disabilitare la neve -->
    <button id="sameTrack" title="Toggle Snow">
      <img src="snowflake.png" alt="Toggle Snow" style="width:19px;height:19px;">
    </button>
    <button id="replayButton" title="Replay">
      <img src="replay.png" alt="Replay" style="width:20px; height:20px;">
    </button>
    <button id="quit" title="New Track">
      <img src="new.png" alt="New Track" style="width:20px;height:20px;">
    </button>
    <!-- Bottone Home -->
    <button id="homeBtn" title="Home">
      <img src="home.png" alt="Home" style="width:18px;height:18px;">
    </button>
    <button id="chronoButton" title="Top 5">
      <img src="stopwatch.png" alt="Top 5" style="width:20px;height:20px;">
    </button>
    <button id="viewBtn" title="View / Save Track">
      <img src="save.png" alt="View / Save" style="width:17px;height:17px;">
    </button>
    <button id="saveResultBtn" title="Save Result">
      <img src="cup.png" alt="Save Result" style="width:18px;height:18px;">
    </button>
  </div>
<button id="challengeButton" title="Challenge Mode">
  üèÖ
</button>

  <!-- UNICA RIGA PER TUTTI I MESSAGGI (tempo + avvisi) -->
  <div class="info-container">
    <p id="infoLine">‚è∞1'00"000'''</p>
  </div>

  <!-- OVERLAY TOP 5 -->
  <div id="chronoOverlay" class="overlay hidden">
    <div class="overlay-content">
      <button id="closeChronoOverlay">X</button>
      <div class="leaderboard-container">
        <div class="leaderboard">
          <h2>Top 5</h2>
          <ol id="leaderboardList"></ol>
        </div>
      </div>
    </div>
  </div>

  <!-- OVERLAY View: per salvare e CARICARE le piste -->
  <div id="viewOverlay" class="overlay hidden">
    <div class="overlay-content">
      <button id="closeViewOverlay">X</button>
      <h2>Saved Tracks</h2>
      <div id="savedTracksList"></div>
      <hr>
      <h3>Save current track</h3>
      <input type="text" id="trackNameInput" placeholder="Enter track name">
      <button id="saveTrackBtn">Save Track</button>
    </div>
  </div>

  <!-- OVERLAY Save Result: per salvare il tempo realizzato -->
  <div id="saveResultOverlay" class="overlay hidden">
    <div class="overlay-content">
      <button id="closeSaveResultOverlay">X</button>
      <h2>Save Your Result</h2>
      <input type="text" id="resultNameInput" placeholder="Enter your name">
      <button id="saveResultConfirmBtn">Save Result</button>
    </div>
  </div>
<div id="challengeIntroOverlay" class="overlay hidden">
  <div class="overlay-content">
    <h2>Welcome to the Solo Challenge!</h2>
    <p>You have 3 attempts to beat the time and advance to the next track!</p>
    <button id="closeChallengeIntroOverlay" class="play-button">Play!</button>
  </div>
</div>
  <!-- OVERLAY TUTORIAL -->
  <div id="tutorialOverlay" class="overlay" style="z-index: 1000;">
    <div class="overlay-content intro-overlay">
      <div id="tutorialContent"></div>
      <div class="tutorial-dots" id="tutorialDots"></div>
      <div class="slides-nav">
        <button class="nav-button" id="tutorialPrev">‚Üê</button>
        <button class="nav-button" id="tutorialStart">Start!</button>
        <button class="nav-button" id="tutorialNext">‚Üí</button>
      </div>
    </div>
  </div>

  <script>
    /* ==============================================
       VARIABILI GLOBALI E IMPOSTAZIONI
    ============================================== */
    const PATH_LENGTH_SCALING = 500;
    const PENALTY_WEIGHT = 0.5;
    const BORDER_THRESHOLD = 5;
    const hardMode = true; // Abilita collisione con alberi

    // Variabile per il controllo della neve: di default la neve √® abilitata
    let snowLocked = false;

    // Variabili per la gestione della neve (come nel campionato)
    let snowIntensity = 0;
    let showSnow = false;
    let weatherState = null;
    function chooseWeatherState(prevState) {
      const r = Math.random() * 100;
      if(r < 60) return "nn";
      else if(r < 80) return "pn";
      else if(r < 95) return "mn";
      else return "nf";
    }
    function applyWeatherState(state) {
      if(state === "nn") { snowIntensity = 0; }
      else if(state === "pn") { snowIntensity = 300; }
      else if(state === "mn") { snowIntensity = 1000; }
      else if(state === "nf") { snowIntensity = 3250;}
      showSnow = (snowIntensity > 0);
      return showSnow;
    }

    let canvas = document.getElementById('canvas');
    let ctx = canvas.getContext('2d');
    let snowCanvas = document.getElementById('snowCanvas');
    let snowCtx = snowCanvas.getContext('2d');

    // ELIMINATI finalTimeOutput E statusOutput, usiamo un UNICO <p id="infoLine">
    const infoLine = document.getElementById('infoLine');
    
    // Per gestire il testo base e i messaggi temporanei
    let mainLabel = "‚è∞1'00\"000'''";
    function setMainLabel(text) {
      mainLabel = text;
      infoLine.innerHTML = text;
    }
    function showTemporaryMessage(msg, duration=2000) {
      let old = mainLabel;
      infoLine.innerHTML = msg;
      infoLine.classList.remove('record');
      setTimeout(() => {
        infoLine.innerHTML = old;
      }, duration);
    }
    function showTemporaryMessageHtml(html, duration=2000) {
      let old = mainLabel;
      infoLine.innerHTML = html;
      infoLine.classList.remove('record');
      setTimeout(() => {
        infoLine.innerHTML = old;
      }, duration);
    }

    // Bottoni
    let sameTrackButton = document.getElementById('sameTrack');
    let replayButton = document.getElementById('replayButton');
    let quitButton = document.getElementById('quit');
    let homeBtn = document.getElementById('homeBtn');
    let chronoButton = document.getElementById('chronoButton');
    let viewBtn = document.getElementById('viewBtn');
    let saveResultBtn = document.getElementById('saveResultBtn');

    // Overlay
    let chronoOverlay = document.getElementById('chronoOverlay');
    let closeChronoOverlay = document.getElementById('closeChronoOverlay');
    let viewOverlay = document.getElementById('viewOverlay');
    let closeViewOverlay = document.getElementById('closeViewOverlay');
    let saveResultOverlay = document.getElementById('saveResultOverlay');
    let closeSaveResultOverlay = document.getElementById('closeSaveResultOverlay');
    let tutorialOverlay = document.getElementById('tutorialOverlay');
    let tutorialContent = document.getElementById('tutorialContent');
    let tutorialDots = document.getElementById('tutorialDots');
    let tutorialPrev = document.getElementById('tutorialPrev');
    let tutorialNext = document.getElementById('tutorialNext');
    let tutorialStart = document.getElementById('tutorialStart');

    // Variabili di gioco
    let currentTrack = null; // { gates, trees }
    let bestTimes = [];      // Array dei migliori tempi della pista corrente
    // Saved tracks saranno salvate in localStorage
    let savedTracks = {};
    // Variabile per ricordare il nome della pista corrente (se salvata)
    let currentTrackName = "";
    // Variabile per salvare il tempo finale appena calcolato
    window.lastFinalTime = 0;
    let gates = [];
    let trees = [];
    let pointsPath = [];
    let drawing = false;
    let startTime = 0;
    let lastCompleteRun = null;
    let outPenaltyCount = 0;
    let isOut = false;
    let falseStartCount = 0;
    let intersectedGates = new Set();
    let didFinishOrFail = false; // Flag per terminazione run

    // Punto di partenza e arrivo
    let startPoint = { x: 150, y: 30 };
    let finishRect = { x: 130, y: 490, width: 40, height: 10 };
    let globalWind = Math.random() * 1 - 0.5;
let isChallengeMode = false; // Se siamo in modalit√† Sfida
let challengeBestTime = 0; // Tempo da battere
let challengeAttempts = 0; // Tentativi usati
    // Tutorial slides
    let tutorialSlides = [
      { title: "Welcome to Ski Solo!", content: "This is a single-player ski game.<br>Start at the house and ski to the finish." },
      { title: "How to Play", content: "Draw your path starting from the house icon. Pass through all gates and finish at the finish area. Avoid trees and boundaries." },
      { title: "Controls", content: "Buttons:<br>üîÅ Toggle Snow<br>‚èØÔ∏è Replay (review run)<br>‚ùå New Track<br>‚è±Ô∏è Top 5 (view best times)<br>üëÅÔ∏è View (save/load track)<br>üèÜ Cup (save your result)" },
      { title: "Good Luck!", content: "Try to beat your best time! Enjoy the slope!" }
    ];
    let currentTutorialIndex = 0;

    const container = document.getElementById('gameContainer');

    function resizeCanvas(){
      canvas.width = container.clientWidth;
      canvas.height = container.clientHeight;
      snowCanvas.width = container.clientWidth;
      snowCanvas.height = container.clientHeight;

      // Aggiorna i punti di start/finish
      startPoint = { x: canvas.width / 2, y: 30 / 520 * canvas.height };
      finishRect = {
        x: (canvas.width / 2) - 20,
        y: canvas.height - 30,
        width: 40,
        height: 10
      };

      drawTrack(currentTrack);
    }
    function clearCanvas(){ ctx.clearRect(0,0,canvas.width, canvas.height); }

    function drawStartPoint() {
      const iconWidth  = 16 / 300 * canvas.width;
      const iconHeight = 16 / 520 * canvas.height;
      ctx.drawImage(startIcon, 
        startPoint.x - iconWidth/2, 
        startPoint.y - iconHeight/2, 
        iconWidth, 
        iconHeight
      );
    }
    function drawFinishArea(){
      const { x, y, width, height } = finishRect;
      const sq = width / 8;
      let rowCount = Math.floor(height / (width / 8));
      for(let row=0; row<rowCount; row++){
        for(let col=0; col<8; col++){
          ctx.fillStyle = ((row+col)%2===0) ? 'black' : '#F0F0F0';
          ctx.fillRect(x+col*sq, y+row*sq, sq, sq);
        }
      }
    }
    const gateIcons = {
      red: new Image(),
      blue: new Image()
    };
    gateIcons.red.src = "red_gate.svg";
    gateIcons.blue.src = "blue_gate.svg";
    const startIcon = new Image();
    startIcon.src = "start.svg";
// Precaricamento dell'immagine dell'albero
const treeImg = new Image();
treeImg.src = "tree.svg"; // Assicurati che il percorso sia corretto

treeImg.onload = () => {
  console.log('Immagine dell\'albero caricata con successo.');
  drawTrack(currentTrack); // Ridisegna la pista una volta caricata l'immagine
};

treeImg.onerror = () => {
  console.error('Errore nel caricamento di tree.svg');
};


    function generateGates(count){
      let startWithRed = (Math.random() < 0.5);
      let isRed = startWithRed;
      let arr = [];
      for(let i=0; i<count; i++){
        let dir = isRed ? 1 : -1;
        let x = isRed 
          ? Math.random()*(canvas.width/2-35)+canvas.width/2
          : Math.random()*(canvas.width/2-35)+35;
        let y = 60 / 520 * canvas.height + i*((canvas.height - (120 / 520 * canvas.height))/count);
        let color = isRed ? 'red' : 'blue';
        arr.push({
          x, y, color,
          line: { x1: x, y1: y, x2: x + dir * (200 / 300 * canvas.width), y2: y }
        });
        isRed = !isRed;
      }
      return arr;
    }
    function generateTrees(gArr){
      let treeCount = Math.floor(Math.random()*3)+6;
      let arr = [];
      const margin = 15 / 520 * canvas.height, 
            minGate = 50 / 300 * canvas.width, 
            minTree = 30 / 520 * canvas.height, 
            minFinish = 50 / 300 * canvas.width, 
            minStart = 40 / 520 * canvas.height;
      while(arr.length < treeCount){
        let tx = margin + Math.random()*(canvas.width-2*margin);
        let ty = 40 / 520 * canvas.height + Math.random()*(canvas.height - (40 / 520 * canvas.height) - margin);
        let closeGate = gArr.some(g=> Math.hypot(tx-g.x, ty-g.y) < minGate);
        let closeTrees = arr.some(t=> Math.hypot(tx-t.x, ty-t.y) < minTree);
        let closeFinish = isNearFinish(tx,ty,finishRect,minFinish);
        let closeStart = Math.hypot(tx-startPoint.x, ty-startPoint.y) < minStart;
        if(!closeGate && !closeTrees && !closeFinish && !closeStart){
          arr.push({ x: tx, y: ty });
        }
      }
      return arr;
    }
    function createTrack(){
      let g = generateGates(8);
      let t = generateTrees(g);
      return { gates: g, trees: t };
    }
    function drawGates(gArr){
      gArr.forEach(g=>{
        let icon = (g.color==="red") ? gateIcons.red : gateIcons.blue;
        let iconWidth = 16 / 300 * canvas.width; 
        let iconHeight = 16 / 520 * canvas.height;
        ctx.drawImage(icon, g.x - iconWidth/2, g.y - iconHeight/2, iconWidth, iconHeight);
      });
    }
function drawTrees(tArr){
  if(!treeImg.complete){
    console.warn('Immagine dell\'albero non ancora caricata.');
    return;
  }
  tArr.forEach(t => {
    const treeWidth = 12 / 300 * canvas.width;
    const treeHeight = 20 / 520 * canvas.height;
    ctx.drawImage(treeImg, t.x - treeWidth / 2, t.y - treeHeight, treeWidth, treeHeight);
  });
}

    function drawTrack(track){
      if(!track) return;
      clearCanvas();
      gates = track.gates;
      trees = track.trees;
      intersectedGates.clear();
      drawStartPoint();
      drawFinishArea();
      drawGates(gates);
      drawTrees(trees);
    }

    /* Neve */
    let snowflakes = [];
    function initSnow(){
      snowflakes = [];
      for(let i=0; i<snowIntensity; i++){
        snowflakes.push({
          x: Math.random()*snowCanvas.width,
          y: Math.random()*snowCanvas.height,
          radius: Math.random()*3+1,
          speedY: Math.random()*0.5+0.5,
          speedX: Math.random()*0.5-0.25
        });
      }
    }
    function updateSnow(){
      if(!showSnow)return;
      snowCtx.clearRect(0,0,snowCanvas.width,snowCanvas.height);
      snowflakes.forEach(flake=>{
        flake.x += flake.speedX + globalWind;
        flake.y += flake.speedY;
        if(flake.y > snowCanvas.height){
          flake.y = 0;
          flake.x = Math.random()*snowCanvas.width;
        }
        if(flake.x > snowCanvas.width) flake.x = 0;
        if(flake.x < 0) flake.x = snowCanvas.width;
        snowCtx.beginPath();
        snowCtx.arc(flake.x, flake.y, flake.radius, 0, Math.PI*2);
        snowCtx.fillStyle = 'white';
        snowCtx.fill();
      });
      requestAnimationFrame(updateSnow);
    }

    /* Eventi mouse / touch */
    if(!canvas._eventsAttached){
      canvas.addEventListener('mousedown', handleMouseDown);
      canvas.addEventListener('mousemove', handleMouseMove);
      canvas.addEventListener('mouseup', handleMouseUp);
      canvas.addEventListener('touchstart', handleTouchStart);
      canvas.addEventListener('touchmove', handleTouchMove);
      canvas.addEventListener('touchend', handleTouchEnd);
      canvas._eventsAttached = true;
    }
    function getMouseCoords(e){
      let rect = canvas.getBoundingClientRect();
      let cx = e.touches ? e.touches[0].clientX : e.clientX;
      let cy = e.touches ? e.touches[0].clientY : e.clientY;
      return { x: (cx - rect.left) / rect.width * canvas.width, y: (cy - rect.top) / rect.height * canvas.height };
    }
    function isNearStartPoint(x,y){ return (Math.hypot(x - startPoint.x, y - startPoint.y) <= 20 / 520 * canvas.height); }

    function handleMouseDown(e){
      let {x,y} = getMouseCoords(e);
      if(!isNearStartPoint(x,y)){
        falseStartCount++;
        if(falseStartCount===1){
          showTemporaryMessageHtml('<span style="color:red;">False start!</span> <span style="color:black;">2nd attempt!</span>', 1500);
        } else if(falseStartCount===2){
          showTemporaryMessageHtml('<span style="color:red;">False start!</span> <span style="color:black;">Last attempt!</span>', 1500);
        } else if(falseStartCount>=3){
          setMainLabel('Run failed due to consecutive false starts!');
          failRun("Run failed due to false starts.");
          falseStartCount = 0;
        }
        return;
      }
      falseStartCount = 0;
      outPenaltyCount = 0;
      isOut = false;
      drawing = true;
      pointsPath = [];
      startTime = performance.now();
      didFinishOrFail = false;

      setMainLabel(""); // reset momentaneamente?
      ctx.beginPath();
      pointsPath.push({ x, y, t: 0 });
      ctx.moveTo(x,y);
    }
    function handleMouseMove(e){
      if(!drawing)return;
      let {x,y} = getMouseCoords(e);
      let p1 = pointsPath[pointsPath.length-1];
      let p2 = { x, y };
      if(p1 && checkInterpolationForBorder(p1,p2)){
        if(!isOut){ outPenaltyCount++; isOut = true; }
      } else { isOut = false; }
      let now = performance.now() - startTime;
      pointsPath.push({ x, y, t: now });
      ctx.lineTo(x,y);
      ctx.strokeStyle = '#a4b8eb';
      ctx.lineWidth = 2 / 520 * canvas.height;
      ctx.stroke();
      checkIntersections();
    }
    function handleMouseUp(e){
      if(!drawing)return;
      drawing = false;
      if(!didFinishOrFail){ failRun("Run interrupted!"); }
    }
    function handleTouchStart(e){
      e.preventDefault();
      let {x,y} = getMouseCoords(e);
      if(!isNearStartPoint(x,y)){
        setMainLabel("You must start from the house icon!");
        return;
      }
      falseStartCount = 0;
      outPenaltyCount = 0;
      isOut = false;
      drawing = true;
      pointsPath = [];
      startTime = performance.now();
      didFinishOrFail = false;

      setMainLabel("");
      ctx.beginPath();
      pointsPath.push({ x, y, t: 0 });
      ctx.moveTo(x,y);
    }
    function handleTouchMove(e){
      e.preventDefault();
      if(!drawing)return;
      let {x,y} = getMouseCoords(e);
      let p1 = pointsPath[pointsPath.length-1];
      let p2 = { x, y };
      if(p1 && checkInterpolationForBorder(p1, p2)){
        if(!isOut){ outPenaltyCount++; isOut = true; }
      } else { isOut = false; }
      let now = performance.now() - startTime;
      pointsPath.push({ x, y, t: now });
      ctx.lineTo(x,y);
      ctx.strokeStyle = '#a4b8eb';
      ctx.lineWidth = 2 / 520 * canvas.height;
      ctx.stroke();
      checkIntersections();
    }
    function handleTouchEnd(e){
      e.preventDefault();
      if(!drawing)return;
      drawing = false;
      if(!didFinishOrFail){ failRun("Run interrupted!"); }
    }
    function checkInterpolationForBorder(p1, p2) {
      const stepLength = 2;
      const dx = p2.x - p1.x;
      const dy = p2.y - p1.y;
      const distance = Math.hypot(dx, dy);
      const steps = Math.ceil(distance / stepLength);
      for (let i = 1; i <= steps; i++) {
        const t = i / steps;
        const ix = p1.x + t * dx;
        const iy = p1.y + t * dy;
        if (ix < BORDER_THRESHOLD || ix > canvas.width - BORDER_THRESHOLD) {
          return true;
        }
      }
      return false;
    }

    /* Collisioni */
    function checkIntersections(){
      for(let i=1; i<pointsPath.length; i++){
        let p1 = pointsPath[i-1], p2 = pointsPath[i];
        // Alberi
        if(hardMode){
          for(const tree of trees){
            let steps = Math.ceil(Math.hypot(p2.x-p1.x, p2.y-p1.y)/5);
            for(let j=0; j<=steps; j++){
              let ix = p1.x + (p2.x-p1.x)*(j/steps);
              let iy = p1.y + (p2.y-p1.y)*(j/steps);
              let dist = Math.hypot(ix - tree.x, iy - (tree.y - 10 / 520 * canvas.height));
              if(dist < 10 / 520 * canvas.height){
                didFinishOrFail = true;
                failRun("You hit a tree!");
                return;
              }
            }
          }
        }
        // Porte
        for(const [idx, gate] of gates.entries()){
          if(linesIntersect(p1.x, p1.y, p2.x, p2.y, gate.line.x1, gate.line.y1, gate.line.x2, gate.line.y2)){
            intersectedGates.add(idx);
          }
        }
        // Finish
        if(isSegmentInFinishArea(p1, p2, finishRect)){
          didFinishOrFail = true;
          if(intersectedGates.size === gates.length){
            finishRun();
          } else {
            failRun("You missed a gate!");
          }
          return;
        }
      }
    }
    function linesIntersect(x1,y1,x2,y2,x3,y3,x4,y4){
      const det = (x2-x1)*(y4-y3) - (y2-y1)*(x4-x3);
      if(det===0)return false;
      const lambda = ((y4-y3)*(x4-x1)+(x3-x4)*(y4-y1))/det;
      const gamma  = ((y1-y2)*(x4-x1)+(x2-x1)*(y4-y1))/det;
      return (lambda>=0 && lambda<=1 && gamma>=0 && gamma<=1);
    }
    function isSegmentInFinishArea(p1, p2, rect){
      if((p1.y < rect.y && p2.y < rect.y) || (p1.y > rect.y+rect.height && p2.y > rect.y+rect.height))
        return false;
      if((p1.x < rect.x && p2.x < rect.x) || (p1.x > rect.x+rect.width && p2.x > rect.x+rect.width))
        return false;
      return true;
    }
    function isNearFinish(x, y, rect, minD){
      return ( x>= rect.x-minD && x<= rect.x+rect.width+minD &&
               y>= rect.y-minD && y<= rect.y+rect.height+minD );
    }

    /* Fine run / fallimento run */
function finishRun() {
  drawing = false;
  didFinishOrFail = true;
  let endTime = performance.now();
  let elapsedTime = endTime - startTime;

  // Calcolo della distanza percorsa e del tempo finale
  let distPx = calculateDistance(pointsPath);
  let baseTime = calculateFinalTime(elapsedTime, distPx);
  let outPenaltyTotal = outPenaltyCount * 0.10;
  let finalTime = baseTime + outPenaltyTotal;

  // Memorizza l'ultima corsa completata
  lastCompleteRun = JSON.parse(JSON.stringify(pointsPath));
  window.lastFinalTime = finalTime;

  // Modalit√† Sfida
if (isChallengeMode) {
  // Mostra il tempo del giocatore
  setMainLabel(`Your time: ${formatTime(finalTime)}`);

  // Verifica se il tempo √® stato battuto
  setTimeout(() => {
    if (finalTime <= challengeBestTime) {
      setMainLabel(`Success! You beat ${formatTime(challengeBestTime)}!`);
      challengeAttempts = 3; // Reset tentativi
      startNewChallenge(); // Genera una nuova pista
    } else {
      challengeAttempts--;
      if (challengeAttempts > 0) {
        setMainLabel(`Try again! ${4 - challengeAttempts}nd attempt!`);
        setTimeout(() => {
          clearCanvas(); // Ripulisce il canvas
          drawTrack(currentTrack); // Ridisegna la stessa pista
          setMainLabel(`Beat this time: ${formatTime(challengeBestTime)}`);
        }, 2000);
      } else {
        setMainLabel("Failed! Retry!");
        challengeAttempts = 3; // Reset dei tentativi
        startNewChallenge(); // Solo ora rigenera la pista
      }
    }
  }, 2000);
}
else {
    // Modalit√† normale
    setMainLabel(
      `‚è∞${formatTime(finalTime)}${outPenaltyTotal > 0 ? ` (+${outPenaltyTotal.toFixed(2)})` : ""}`
    );
    updateBestTimes(finalTime, lastCompleteRun);

    // Aggiorna i migliori tempi in localStorage se la pista √® salvata
    if (currentTrackName !== "") {
      savedTracks[currentTrackName].bestTimes = bestTimes;
      storeSavedTracks();
    }
  }

  // Reset dopo 2 secondi (solo modalit√† normale)
  if (!isChallengeMode) {
    setTimeout(() => {
      resetRun();
    }, 2000);
  }
}


function failRun(msg) {
  drawing = false;
  didFinishOrFail = true;
  setMainLabel(msg);

  // Salva la corsa completata anche se fallita
  lastCompleteRun = JSON.parse(JSON.stringify(pointsPath));

  if (isChallengeMode) {
    // Modalit√† Sfida: considera l'errore come un tentativo fallito
    challengeAttempts--; // Decrementa i tentativi rimanenti

    setTimeout(() => {
      if (challengeAttempts > 0) {
        // Se ci sono tentativi rimanenti
        setMainLabel(`Try again! ${4 - challengeAttempts}nd attempt!`);
        setTimeout(() => {
          clearCanvas(); // Ripulisce il canvas
          drawTrack(currentTrack); // Ridisegna la stessa pista
          setMainLabel(`Beat this time: ${formatTime(challengeBestTime)}`);
        }, 2000);
      } else {
        // Se i tentativi sono terminati
        setMainLabel("Failed! Retry!");
        setTimeout(() => {
          startNewChallenge(); // Genera una nuova pista e un nuovo tempo da battere
        }, 2000);
      }
    }, 2000);
  } else {
    // Modalit√† Normale: resetta semplicemente la corsa
    setTimeout(() => {
      resetRun(); // Resetta tutto come prima
    }, 2000);
  }
}


    function calculateDistance(arr){
      let tot = 0;
      for(let i=1; i<arr.length; i++){
        let dx = arr[i].x - arr[i-1].x;
        let dy = arr[i].y - arr[i-1].y;
        tot += Math.hypot(dx, dy);
      }
      return tot;
    }
    function calculateFinalTime(ms, dist){
      let s = ms/1000;
      let penalty = PENALTY_WEIGHT * (dist / PATH_LENGTH_SCALING);
      return 60 + s + penalty;
    }
    function formatTime(sec){
      let m = Math.floor(sec/60);
      let r = (sec % 60).toFixed(3);
      return `${m}'${r.replace('.', '"')}'''`;
    }
    function updateBestTimes(time, replayData){
      let result = { name: "Anonymous", time, replay: replayData };
      bestTimes.push(result);
      bestTimes.sort((a,b)=> a.time - b.time);
      if(bestTimes.length>5) bestTimes.length = 5;
      // Se √® un nuovo record
      if(bestTimes[0].time === time){
        infoLine.classList.add('record');
        setTimeout(() => {
          infoLine.classList.remove('record');
        }, 2000);
      }
    }
function toggleChallengeMode() {
  if (isChallengeMode) {
    // Esci dalla modalit√† medaglia
    isChallengeMode = false;
    challengeAttempts = 0;
    setMainLabel("‚è∞1'00\"000'''"); // Resetta il tempo
    toggleButtonState(false); // Riattiva i pulsanti
    alert("Exited Challenge Mode. Back to normal play.");
  } else {
    // Mostra il popup introduttivo
    document.getElementById('challengeIntroOverlay').classList.remove('hidden');
  }
}
document.getElementById('challengeButton').addEventListener('click', toggleChallengeMode);
function toggleButtonState(disable) {
  // Elenco dei pulsanti da disattivare
  const buttonsToDisable = [
    document.getElementById('chronoButton'), // Pulsante "Coppa"
    document.getElementById('sameTrack'), // Pulsante "Neve/Non neve"
    document.getElementById('quit'), // Pulsante "New Track"
    document.getElementById('saveResultBtn') // Pulsante "Save Result"
  ];

  buttonsToDisable.forEach((button) => {
    if (disable) {
      button.disabled = true; // Disattiva il pulsante
      button.classList.add('button-disabled'); // Aggiunge stile disattivato
    } else {
      button.disabled = false; // Riattiva il pulsante
      button.classList.remove('button-disabled'); // Rimuove stile disattivato
    }
  });
}


function startNewChallenge() {
  // Genera una nuova pista casuale
  currentTrack = createTrack();
  drawTrack(currentTrack);

  // Calcola la lunghezza della traiettoria ideale
  let idealLength = calculateIdealPath(currentTrack.gates);
  challengeBestTime = calculateFinalTime(idealLength * 1.5, idealLength); // Tempo stimato con deviazione
  setMainLabel(`Beat this time: ${formatTime(challengeBestTime)}`);
}
function calculateIdealPath(gates) {
  let length = 0;
  for (let i = 1; i < gates.length; i++) {
    let dx = gates[i].x - gates[i - 1].x;
    let dy = gates[i].y - gates[i - 1].y;
    length += Math.hypot(dx, dy);
  }
  return length;
}

    /* Replay */
    function replayTrajectory(customPoints){
      let rp = (customPoints && customPoints.length>=2) ? customPoints : pointsPath;
      if(!rp || rp.length<2){
        showTemporaryMessage("No run to replay!", 1000);
        return;
      }
      clearCanvas();
      drawStartPoint();
      drawFinishArea();
      drawGates(gates);
      drawTrees(trees);
      let i = 0;
      function step(){
        if(i>=rp.length-1){
          setTimeout(()=>{
            clearCanvas();
            drawTrack(currentTrack);
          },500);
          return;
        }
        ctx.beginPath();
        ctx.moveTo(rp[i].x, rp[i].y);
        ctx.lineTo(rp[i+1].x, rp[i+1].y);
        ctx.strokeStyle = '#a4b8eb';
        ctx.lineWidth = 2 / 520 * canvas.height;
        ctx.stroke();
        let dt = rp[i+1].t - rp[i].t;
        i++;
        setTimeout(step, dt);
      }
      setTimeout(step, 0);
    }

    /* Bottoni */
    sameTrackButton.addEventListener('click', ()=> { 
      snowLocked = !snowLocked;
      if(snowLocked){
        sameTrackButton.style.opacity = "0.5";  
        showTemporaryMessage("Snow locked", 1000);
      } else {
        sameTrackButton.style.opacity = "1";    
        showTemporaryMessage("Snow enabled", 1000);
      }
      resetRun();
    });
    replayButton.addEventListener('click', ()=>{
      if(lastCompleteRun && lastCompleteRun.length>=2){
        replayTrajectory(lastCompleteRun);
      } else {
        showTemporaryMessage("No run to replay!", 1000);
      }
    });
    quitButton.addEventListener('click', ()=>{
      currentTrack = createTrack();
      bestTimes = [];
      currentTrackName = "";
      lastCompleteRun = null;
      resetRun();
      drawTrack(currentTrack);
    });
    chronoButton.addEventListener('click', ()=>{
      updateLeaderboard();
      chronoOverlay.classList.remove('hidden');
    });
    closeChronoOverlay.addEventListener('click', ()=>{ chronoOverlay.classList.add('hidden'); });
    viewBtn.addEventListener('click', ()=>{
      updateSavedTracksList();
      viewOverlay.classList.remove('hidden');
    });
    closeViewOverlay.addEventListener('click', ()=>{ viewOverlay.classList.add('hidden'); });
    saveResultBtn.addEventListener('click', ()=>{ saveResultOverlay.classList.remove('hidden'); });
    closeSaveResultOverlay.addEventListener('click', ()=>{ saveResultOverlay.classList.add('hidden'); });
// Listener per il popup della modalit√† medaglia
document.getElementById('closeChallengeIntroOverlay').addEventListener('click', () => {
  document.getElementById('challengeIntroOverlay').classList.add('hidden');
  isChallengeMode = true;
  challengeAttempts = 3;
  toggleButtonState(true);
  startNewChallenge();
});
    document.getElementById('saveResultConfirmBtn').addEventListener('click', ()=>{
      let name = document.getElementById('resultNameInput').value.trim();
      if(name===""){
        alert("Please enter a name.");
        return;
      }
      if(typeof window.lastFinalTime !== 'number' || window.lastFinalTime === 0){
        alert("No valid final time recorded!");
        return;
      }
      let found = bestTimes.find(item => item.name === "Anonymous" && item.time === window.lastFinalTime);
      if(found){
        found.name = name;
      } else {
        bestTimes.push({ name, time: window.lastFinalTime, replay: lastCompleteRun });
      }
      bestTimes.sort((a,b)=> a.time - b.time);
      if(bestTimes.length>5) bestTimes.length = 5;
      saveResultOverlay.classList.add('hidden');
      updateLeaderboard();
    });

    function resetRun(){
      drawing = false;
      didFinishOrFail = false;
      pointsPath = [];
      setMainLabel("‚è∞1'00\"000'''"); // Tornare al default
      clearCanvas();
      drawTrack(currentTrack);
      globalWind = Math.random() * 1 - 0.5;
      weatherState = chooseWeatherState(weatherState);
      applyWeatherState(weatherState);
      if(snowLocked){
        snowCanvas.classList.add('hidden');
      } else {
        if(showSnow){
          snowCanvas.classList.remove('hidden');
          initSnow();
          updateSnow();
        } else {
          snowCanvas.classList.add('hidden');
        }
      }
    }

    function updateLeaderboard(){
      let lb = document.getElementById('leaderboardList');
      lb.innerHTML = "";
      bestTimes.forEach((entry, i)=>{
        let li = document.createElement('li');
        if(i===0){
          li.innerHTML = `${entry.name} - ${formatTime(entry.time)} <span style="font-size:18px; cursor:pointer;" title="Click to watch the best replay">‚èØÔ∏è</span>`;
          li.style.fontWeight = 'bold';
          li.addEventListener('click', ()=>{
            chronoOverlay.classList.add('hidden');
            replayTrajectory(entry.replay);
          });
        } else {
          li.textContent = `${entry.name} - ${formatTime(entry.time)}`;
        }
        lb.appendChild(li);
      });
    }

    /* Gestione localStorage piste salvate */
    const LS_KEY = "skiSolo_savedTracks";
    function loadSavedTracks() {
      let saved = localStorage.getItem(LS_KEY);
      if(saved) {
        try {
          savedTracks = JSON.parse(saved);
        } catch(e) {
          savedTracks = {};
        }
      } else {
        savedTracks = {};
      }
    }
    function storeSavedTracks() {
      localStorage.setItem(LS_KEY, JSON.stringify(savedTracks));
    }
    function updateSavedTracksList(){
      loadSavedTracks();
      let listDiv = document.getElementById('savedTracksList');
      listDiv.innerHTML = "";
      for(let name in savedTracks){
        let container = document.createElement('div');
        container.style.display = "flex";
        container.style.alignItems = "center";
        container.style.justifyContent = "space-between";
        container.style.margin = "5px 0";
        let span = document.createElement('span');
        span.textContent = name;
        span.style.cursor = "pointer";
        span.addEventListener('click', ()=>{
          let saved = savedTracks[name];
          currentTrack = saved.track;
          bestTimes = saved.bestTimes || [];
          currentTrackName = name;
          resizeCanvas();
          resetRun();
          viewOverlay.classList.add('hidden');
        });
        let delBtn = document.createElement('button');
        delBtn.textContent = "Delete";
        delBtn.className = "deleteBtn";
        delBtn.addEventListener('click', ()=>{
          if(confirm(`Are you sure you want to delete the track "${name}"?`)){
            delete savedTracks[name];
            storeSavedTracks();
            updateSavedTracksList();
          }
        });
        container.appendChild(span);
        container.appendChild(delBtn);
        listDiv.appendChild(container);
      }
    }
    document.getElementById('saveTrackBtn').addEventListener('click', ()=>{
      let trackName = document.getElementById('trackNameInput').value.trim();
      if(trackName===""){
        alert("Enter a track name.");
        return;
      }
      savedTracks[trackName] = { track: currentTrack, bestTimes: [...bestTimes] };
      currentTrackName = trackName;
      storeSavedTracks();
      alert("Track saved!");
      updateSavedTracksList();
      viewOverlay.classList.add('hidden');
    });

    /* Tutorial */
    function renderTutorial(){
      let slide = tutorialSlides[currentTutorialIndex];
      tutorialContent.innerHTML = `<h2>${slide.title}</h2><p>${slide.content}</p>`;
      tutorialDots.innerHTML = "";
      
      tutorialSlides.forEach((s, i) => {
        let d = document.createElement('div');
        d.className = "dot" + (i === currentTutorialIndex ? " active" : "");
        d.addEventListener('click', () => {
          currentTutorialIndex = i;
          renderTutorial();
        });
        tutorialDots.appendChild(d);
      });
      tutorialStart.style.display = "inline-block";
      tutorialPrev.style.display = "inline-block";
      tutorialNext.style.display = "inline-block";
    }
    tutorialPrev.addEventListener('click', ()=>{
      if(currentTutorialIndex > 0){
        currentTutorialIndex--;
        renderTutorial();
      }
    });
    tutorialNext.addEventListener('click', ()=>{
      if(currentTutorialIndex < tutorialSlides.length -1){
        currentTutorialIndex++;
        renderTutorial();
      }
    });
    tutorialStart.addEventListener('click', ()=>{
      tutorialOverlay.classList.add('hidden');
      startGame();
    });
    function startGame(){
      loadSavedTracks();
      currentTrack = createTrack();
      bestTimes = [];
      currentTrackName = "";
      resizeCanvas();
      resetRun();
      drawTrack(currentTrack);
    }
    renderTutorial();

    document.getElementById('homeBtn').addEventListener('click', function() {
      if (confirm('Are you sure you want to quit?')) { 
        location.href = 'index.html';
      }
    });

    window.onload = function() {
      resizeCanvas();
    };
  </script>
</body>
</html>
