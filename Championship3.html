<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <!-- Disabilita pinch-to-zoom / doppio tap -->
  <meta name="viewport"
        content="width=300, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>

  <title>Ski Championship</title>
  <style>
    /* (stili invariati) */
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: "Helvetica Neue", Arial, sans-serif;
      background: #ffffff;
    }
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .container {
      position: relative;
      width: 300px;
      height: 520px;
      /* Sfondo immagine */
      background: #e1dffc url("sfondo.png") no-repeat center center;
      background-size: cover;

      border: 2px solid #e9effb;
      border-radius: 10px;
      margin-top: 20px;
      box-sizing: border-box;
      overflow: hidden;
    }
    canvas {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      cursor: crosshair;
    }

    button {
      border: none;
      background: none;
      cursor: pointer;
      font-size: 18px;
      margin: 0; padding: 0;
      color: black; 
    }
    button:hover { opacity: 0.7; }

    /* Bottoni */
    #sameTrack {
      position: absolute; bottom: 10px; left: 10px;
    }
    #replayButton {
      position: absolute; bottom: 10px; left: 50px;
    }
    #quit {
      position: absolute; bottom: 4px; right: 10px;
    }
    #chronoButton {
      position: absolute; top: 10px; right: 10px;
    }

    /* Nuovo bottone BLIND */
    #blindToggle {
      font-size: 18px;
    padding: 5px 8px;
    position: absolute;
    bottom: 0px;
    left: 100px; /* Posizionato a sinistra del bottone alberi */
    transform: translateX(-50%);
    cursor: pointer;
}


    #addPlayerBtn, #removePlayerBtn {
      font-size: 12px;
    }

    .info-container {
      margin-top: 13px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    #finalTimeOutput {
      margin: -10px 0;
      font-weight: bold;
    }
    #statusOutput {
      margin: 15px 0;
      font-weight: bold;
      color: red;
      min-height: 20px;
    }

    @keyframes blink {
      0%, 100% { opacity: 1; }
      50%      { opacity: 0; }
    }
    .record {
      animation: blink 0.5s ease-in-out 3;
    }

    .overlay {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background-color: rgba(0, 0, 0, 0.7);
      z-index: 9999;
      display: flex;
      justify-content: center;
      align-items: center;
      animation: fadeIn 0.3s ease;
    }
    @keyframes fadeIn {
      from { opacity: 0; }
      to   { opacity: 1; }
    }
    .hidden {
      display: none;
    }
    .overlay-content {
      background-color: #fff;
      border-radius: 12px;
      padding: 20px;
      width: 90%;
      max-width: 600px;
      box-sizing: border-box;
      position: relative;
      text-align: center;
      color: #333;
    }
    #chronoOverlay .overlay-content {
      max-width: 700px;
    }
    #closeOverlay {
      position: absolute; top: 10px; left: 10px;
      background-color: #dc3545;
      font-size: 14px; padding: 5px 10px;
      color: white; border: none; border-radius: 5px;
      cursor: pointer;
    }
    #closeOverlay:hover {
      background-color: #c82333;
    }

    .leaderboard-container {
      display: block; width: 100%; margin-top: 10px;
    }
    .leaderboard {
      width: 80%; margin: 0 auto;
    }
    .leaderboard h2 {
      text-align: center; margin: 10px 0;
    }
    ol {
      border: 1px solid #ccc; border-radius: 5px;
      list-style: decimal inside; min-height: 100px;
      padding: 10px; margin: 0;
    }
    li { padding: 5px 0; }

    .intro-overlay { }
    .slide-content {
      margin-bottom: 20px; line-height: 1.4;
    }
    .slide-title {
      margin-top: 0; margin-bottom: 10px; font-size: 22px;
    }

    .slides-nav {
      display: flex; justify-content: space-between;
      align-items: center; margin-top: 15px;
    }
    .slides-nav .nav-button {
      background: #007bff; color: #fff;
      border: none; border-radius: 8px;
      padding: 8px 14px; font-size: 14px; cursor: pointer;
    }
    .slides-nav .nav-button:disabled {
      background: #999; cursor: not-allowed;
    }
    .tutorial-dots {
      display: flex; justify-content: center; gap: 8px;
      margin: 10px 0;
    }
    .dot {
      width: 10px; height: 10px; border-radius: 50%;
      background: #ccc; cursor: pointer;
      transition: background 0.3s;
    }
    .dot.active {
      background: #007bff;
    }

    .champ-table {
      margin: 15px 0; border: 1px solid #ccc;
      border-radius: 8px; width: 100%; overflow: hidden;
      text-align: left;
    }
    .champ-table table {
      width: 100%; border-collapse: collapse;
    }
    .champ-table th, .champ-table td {
      padding: 8px; border-bottom: 1px solid #eee;
    }
    .champ-table th {
      background: #f7f7f7; font-weight: bold;
    }
    .champ-table tr:last-child td {
      border-bottom: none;
    }

    .end-buttons {
      display: flex; justify-content: center; gap: 10px;
      margin-top: 20px;
    }
    .end-buttons button {
      background: #007bff; color: #fff;
      border: none; border-radius: 8px;
      padding: 8px 14px; font-size: 14px;
      cursor: pointer;
    }
    .end-buttons button:hover {
      background-color: #0056b3;
    }
  </style>
</head>
<body>
  <!-- Facoltativo: calibrazione -->
  <div id="calibrationTest" style="width:1in; position:absolute; left:-1000px; top:-1000px;"></div>

  <div class="container">
    <canvas id="canvas"></canvas>

    <!-- Bottoni di controllo -->
    <button id="sameTrack" title="Same Run">üîÅ</button>
    <button id="replayButton" title="Replay">‚èØÔ∏è</button>
   <button id="chronoButton" title="Chrono">
  <img src="stopwatch.png" alt="Chrono" style="width:24px; height:24px;">
</button>
<button id="quit" onclick="location.href='index.html'" title="Close">
  <img src="close.png" alt="Close" style="width:22px; height:22px;">
</button>

    <!-- (NEW) Bottone per Blind Mode -->
    <button id="blindToggle" title="Toggle Blind Mode">
  <img id="blindIcon" src="view.png" alt="View Mode" style="width:24px; height:24px;">
</button>

    <!-- Overlay CHRONO (Top 5) -->
    <div id="chronoOverlay" class="overlay hidden">
      <div class="overlay-content">
        <button id="closeOverlay">X</button>
        <div class="leaderboard-container">
          <div class="leaderboard">
            <h2>Top 5</h2>
            <ol id="leaderboardList"></ol>
          </div>
        </div>

<!-- Nuova sezione Classifica Punti -->
<div class="leaderboard-container">
  <div class="leaderboard">
    <h2>Classifica Punti</h2>
    <div class="champ-table">
      <table id="pointsLeaderboardTable">
        <!-- I dati verranno aggiunti dinamicamente -->
        <thead>
          <tr>
            <th>Player</th>
            <th>Punti</th>
          </tr>
        </thead>
        <tbody id="pointsLeaderboardBody">
          <!-- Qui verranno inserite le righe della classifica -->
        </tbody>
      </table>
    </div>
  </div>
</div>

      </div>
    </div>
  </div>

  <!-- Info in basso -->
  <div class="info-container">
    <p id="finalTimeOutput">‚è∞1'00"000'''</p>
    <p id="statusOutput"></p>
  </div>

  <!-- OVERLAY INTRO E SLIDES -->
  <div id="slidesOverlay" class="overlay hidden">
    <div id="slidesContent" class="overlay-content intro-overlay"></div>
  </div>

  <!-- OVERLAY ANNUNCI E CLASSIFICHE -->
  <div id="champOverlay" class="overlay hidden">
    <div id="champContent" class="overlay-content"></div>
  </div>

  <script>
    /* ==============================================
       Modalit√† Blind:
       - Nuova var isBlind +3 pt se la run in top5
         E icone: üëÅÔ∏è / üôà
    =============================================== */

    // Calibrazione
    window.addEventListener('load', ()=>{
      const cal = document.getElementById('calibrationTest');
      window.conversionFactor = cal.offsetWidth / 96;
    });

    /* Variabili globali */
    const PATH_LENGTH_SCALING = 500;
    const PENALTY_WEIGHT      = 0.5;

    const canvas         = document.getElementById('canvas');
    const ctx            = canvas.getContext('2d');
    const finalTimeOutput= document.getElementById('finalTimeOutput');
    const statusOutput   = document.getElementById('statusOutput');
    const sameTrackButton= document.getElementById('sameTrack');
    const replayButton   = document.getElementById('replayButton');
    const chronoButton   = document.getElementById('chronoButton');
    const chronoOverlay  = document.getElementById('chronoOverlay');
    const closeOverlay   = document.getElementById('closeOverlay');
    const slidesOverlay  = document.getElementById('slidesOverlay');
    const slidesContent  = document.getElementById('slidesContent');
    const champOverlay   = document.getElementById('champOverlay');
    const champContent   = document.getElementById('champContent');

    // (NEW) bottone Blind
    const blindToggleButton = document.getElementById('blindToggle');

    // (NEW) Stato blind
    let isBlind = false;

    let bestTimes        = [];
    let currentTrack     = null;
    let gates            = [];
    let trees            = [];
    let pointsPath       = [];
    let drawing          = false;
    let startTime        = 0;
    let intersectedGates = new Set();

    let participants     = [];
    let championScores   = {};
    let currentIndex     = 0;
    let attemptCount     = 0;
    let raceNumber       = 1;
    let runNumber        = 1;
    const CHAMPION_POINTS= [9,7,5,3,1];

    let hardMode         = true;
    let slidesIntro      = [];
    let currentSlideIndex= 0;
    let didFinishOrFailThisRun = false;

    let lastStatusMessage = '';
    let lastCompleteRun   = null;
let falseStartCount = 0;
    // (NEW) Toggle Blind Mode
// (NEW) Toggle Blind Mode
blindToggleButton.addEventListener('click', () => {
  isBlind = !isBlind;
  const blindIcon = document.getElementById('blindIcon');

  if (isBlind) {
    // Cambia immagine a "hide.png"
    blindIcon.src = 'hide.png';
    blindIcon.alt = 'Hide Mode';
  } else {
    // Cambia immagine a "view.png"
    blindIcon.src = 'view.png';
    blindIcon.alt = 'View Mode';
  }
});


    /* Setup canvas */
    let startPoint = { x:150, y:20 };
    let finishRect = { x:130, y:490, width:40, height:10 };
// Caricamento delle icone SVG per le porte
const gateIcons = {
  red: new Image(),
  blue: new Image(),
};
gateIcons.red.src = "red_gate.svg"; // Sostituisci con il percorso del file SVG per la porta rossa
gateIcons.blue.src = "blue_gate.svg"; // Sostituisci con il percorso del file SVG per la porta blu

// Assicurati che le icone siano pronte prima di disegnare
gateIcons.red.onload = gateIcons.blue.onload = () => {
  if (currentTrack) drawTrack(currentTrack);
};

    function resizeCanvas(){
      canvas.width = 300;
      canvas.height= 520;
      startPoint={x: canvas.width/2, y:20};
      finishRect={x: (canvas.width/2)-20, y: canvas.height-30, width:40, height:10};
    }
    function clearCanvas(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
    }

    /* Generazione piste */
    function createTrackForRace(rn){
      let gc=8;
      if(rn===2) gc=10;
      if(rn===3) gc=6;
      const g= generateGates(gc);
      const t= generateTrees(g);
      return { gates:g, trees:t };
    }
   function generateGates(count) {
  const startWithRed = (Math.random() < 0.5);
  let isRed = startWithRed;
  let arr = [];
  for (let i = 0; i < count; i++) {
    const dir = isRed ? 1 : -1;

    // Raddoppio della distanza minima laterale (orizzontale)
    const x = isRed
      ? Math.random() * (canvas.width / 2 - 40) + canvas.width / 2 // Porta rossa
      : Math.random() * (canvas.width / 2 - 40) + 40;              // Porta blu

    // Mantieni invariata la distanza verticale
    const y = 60 + i * ((canvas.height - 120) / count);

    const color = isRed ? 'red' : 'blue';
    arr.push({
      x,
      y,
      color,
      line: { x1: x, y1: y, x2: x + dir * 200, y2: y }
    });
    isRed = !isRed;
  }
  return arr;
}

    function generateTrees(gArr){
      const treeCount= Math.floor(Math.random()*3)+6;
      let arr=[];
      const margin=15;
      const minGate=50, minTree=30, minFinish=50, minStart=20;
      while(arr.length<treeCount){
        const tx= margin + Math.random()*(canvas.width-2*margin);
        const ty= margin + Math.random()*(canvas.height-2*margin);

        const closeGate = gArr.some(g=> (Math.hypot(tx-g.x,ty-g.y)<minGate));
        const closeTrees= arr.some(t=> (Math.hypot(tx-t.x,ty-t.y)<minTree));
        const closeFinish= isNearFinish(tx,ty,finishRect,minFinish);
        const closeStart = (Math.hypot(tx-startPoint.x,ty-startPoint.y)<minStart);

        if(!closeGate && !closeTrees && !closeFinish && !closeStart){
          arr.push({x:tx,y:ty});
        }
      }
      return arr;
    }

    /* Disegno pista */
    function drawTrack(track){
      clearCanvas();
      gates= track.gates;
      trees= track.trees;
      drawStartPoint();
      drawFinishArea();
      drawGates(gates);
      drawTrees(trees);
    }
    function drawStartPoint(){
      ctx.font='18px Arial';
      ctx.textAlign='center';
      ctx.textBaseline='middle';
      ctx.fillText('üè†', startPoint.x, startPoint.y);
    }
    function drawFinishArea(){
      const{x,y,width,height}=finishRect;
      const sq=width/8;
      const rowCount=Math.floor(height/(width/8));
      for(let row=0; row<rowCount; row++){
        for(let col=0; col<8; col++){
          ctx.fillStyle=((row+col)%2===0)?'black':'#F0F0F0';
          ctx.fillRect(x+col*sq, y+row*sq, sq, sq);
        }
      }
    }
    function drawGates(gArr) {
  gArr.forEach(g => {
    const icon = g.color === "red" ? gateIcons.red : gateIcons.blue;
    const iconWidth = 16; // Larghezza dell'icona SVG
    const iconHeight = 16; // Altezza dell'icona SVG

    // Disegna l'icona SVG centrata sulle coordinate della porta
    ctx.drawImage(icon, g.x - iconWidth / 2, g.y - iconHeight / 2, iconWidth, iconHeight);

    // Disegna la linea di controllo per la porta (parte dal centro verso l'esterno)
    ctx.strokeStyle = "transparent";
    ctx.beginPath();
    ctx.moveTo(g.line.x1, g.line.y1);
    ctx.lineTo(g.line.x2, g.line.y2);
    ctx.stroke();
  });
}

    function drawTrees(tArr) {
  const treeImg = new Image(); // Creiamo un'immagine
  treeImg.src = './tree.svg'; // Percorso del file SVG

  treeImg.onload = () => { // Quando l'immagine √® caricata
    tArr.forEach(t => {
      // Centra e scala l'immagine in base alle dimensioni del file
      ctx.drawImage(treeImg, t.x - 6, t.y - 20, 12, 20); // 12x20 dimensioni effettive
    });
  };
}


    /* Eventi mouse/touch */
    if(!canvas._eventsAttached){
      canvas.addEventListener('mousedown', handleMouseDown);
      canvas.addEventListener('mousemove', handleMouseMove);
      canvas.addEventListener('mouseup',   handleMouseUp);
      canvas.addEventListener('touchstart',handleTouchStart);
      canvas.addEventListener('touchmove', handleTouchMove);
      canvas.addEventListener('touchend',  handleTouchEnd);
      canvas._eventsAttached=true;
    }
    function getMouseCoords(e){
      const rect= canvas.getBoundingClientRect();
      const cx = (e.touches)? e.touches[0].clientX : e.clientX;
      const cy = (e.touches)? e.touches[0].clientY : e.clientY;
      return {x:cx-rect.left, y:cy-rect.top};
    }
    function isNearStartPoint(x,y){
      return (Math.hypot(x-startPoint.x,y-startPoint.y)<=20);
    }

    function handleMouseDown(e){
      const {x,y}= getMouseCoords(e);
      if (!isNearStartPoint(x, y)) {
  statusOutput.textContent = 'False start! Try again!';
  falseStartCount++;

  // Se ci sono stati tre "False start" consecutivi
  if (falseStartCount >= 3) {
    statusOutput.textContent = 'Run failed due to consecutive false starts!';
    failAttempt("Run failed due to false starts.");
    falseStartCount = 0; // Resetta il contatore per la prossima run
  }
  return;
}
  falseStartCount = 0; // Resetta il contatore per i "False start"    
drawing=true;
      pointsPath=[];
      startTime= performance.now();
      statusOutput.textContent='';
      lastStatusMessage='';
      ctx.beginPath();
      pointsPath.push({x,y,t:0});
      ctx.moveTo(x,y);
      didFinishOrFailThisRun=false;
    }
    function handleMouseMove(e){
      if(!drawing)return;
      const{ x,y }= getMouseCoords(e);
      const now = performance.now()-startTime;
      pointsPath.push({x,y,t:now});

      // (NEW) Se isBlind, NON disegniamo la traccia
      if(!isBlind){
        ctx.lineTo(x,y);
        ctx.strokeStyle='#a4b8eb';
        ctx.lineWidth=2;
        ctx.stroke();
      }
      checkIntersections();
    }
    function handleMouseUp(e){
      if(!drawing)return;
      drawing=false;
      if(!didFinishOrFailThisRun){
        failAttempt("Run interrupted!");
      }
    }

    function handleTouchStart(e){
      e.preventDefault();
      const{ x,y }= getMouseCoords(e);
      if(!isNearStartPoint(x,y)){
        statusOutput.textContent='You must start from the start point!';
        return;
      }
      drawing=true;
      pointsPath=[];
      startTime= performance.now();
      statusOutput.textContent='';
      lastStatusMessage='';
      ctx.beginPath();
      pointsPath.push({x,y,t:0});
      ctx.moveTo(x,y);
      didFinishOrFailThisRun=false;
    }
    function handleTouchMove(e){
      e.preventDefault();
      if(!drawing)return;
      const{ x,y }= getMouseCoords(e);
      const now= performance.now()-startTime;
      pointsPath.push({x,y,t:now});

      // (NEW) Se isBlind, NON disegniamo la traccia
      if(!isBlind){
        ctx.lineTo(x,y);
        ctx.strokeStyle='#a4b8eb';
        ctx.lineWidth=2;
        ctx.stroke();
      }
      checkIntersections();
    }
    function handleTouchEnd(e){
      e.preventDefault();
      if(!drawing)return;
      drawing=false;
      if(!didFinishOrFailThisRun){
        failAttempt("Run interrupted!");
      }
    }

    function checkIntersections(){
      for(let i=1; i<pointsPath.length; i++){
        const p1= pointsPath[i-1], p2= pointsPath[i];
        if(hardMode){
          for(const tree of trees){
            const steps=Math.ceil(Math.hypot(p2.x-p1.x,p2.y-p1.y)/5);
            for(let j=0;j<=steps;j++){
              const ix= p1.x+(p2.x-p1.x)*(j/steps);
              const iy= p1.y+(p2.y-p1.y)*(j/steps);
              const dist=Math.hypot(ix-tree.x, iy-tree.y);
              if(dist<10){
                failAttempt("You hit a tree!");
                return;
              }
            }
          }
        }
        for(const [idx,gate] of gates.entries()){
          if(linesIntersect(p1.x,p1.y,p2.x,p2.y,gate.line.x1,gate.line.y1,gate.line.x2,gate.line.y2)){
            intersectedGates.add(idx);
          }
        }
        if(isSegmentInFinishArea(p1,p2,finishRect)){
          if(intersectedGates.size===gates.length){
            finishRun();
          } else {
            failAttempt("You missed a gate!");
          }
          return;
        }
      }
    }
    function linesIntersect(x1,y1,x2,y2,x3,y3,x4,y4){
      const det=(x2-x1)*(y4-y3)-(y2-y1)*(x4-x3);
      if(det===0)return false;
      const lambda=((y4-y3)*(x4-x1)+(x3-x4)*(y4-y1))/det;
      const gamma=((y1-y2)*(x4-x1)+(x2-x1)*(y4-y1))/det;
      return(lambda>=0&&lambda<=1&&gamma>=0&&gamma<=1);
    }
    function isSegmentInFinishArea(p1,p2,rect){
      if((p1.y<rect.y && p2.y<rect.y) ||
         (p1.y>rect.y+rect.height && p2.y>rect.y+rect.height))return false;
      if((p1.x<rect.x && p2.x<rect.x) ||
         (p1.x>rect.x+rect.width && p2.x>rect.x+rect.width))return false;
      return true;
    }
    function isNearFinish(x,y,rect,minD){
      return(
        x>=rect.x-minD && x<=rect.x+rect.width+minD &&
        y>=rect.y-minD && y<=rect.y+rect.height+minD
      );
    }

    /* TENTATIVI */
function failAttempt(msg) {
  drawing = false;
  didFinishOrFailThisRun = true;
  statusOutput.textContent = msg;
  lastStatusMessage = msg;
  attemptCount++;

  // Se la modalit√† Blind √® attiva, penalizziamo il giocatore
  if (isBlind) {
    participants.forEach((participant, index) => {
      // +3 a tutti gli avversari
      if (index !== currentIndex) {
        championScores[participant] += 3;
      }
    });

    // Aggiungi un messaggio di penalit√† per chiarezza
    statusOutput.textContent = `${msg} Blind failed! Penalty!`;
  }

  // Resetta la modalit√† Blind
  resetBlindMode();

  setTimeout(() => nextParticipant(), 1200);
}


  function finishRun() {
  drawing = false;
  didFinishOrFailThisRun = true;
  const endTime = performance.now();
  const elapsedTime = endTime - startTime;
  const distPx = calculateDistance(pointsPath);
  const realLength = distPx * (window.conversionFactor || 1);
  const finalTime = calculateFinalTime(elapsedTime, realLength);

  finalTimeOutput.textContent = `‚è∞ ${formatTime(finalTime)}`;
  statusOutput.textContent = 'Finished!';
  lastStatusMessage = 'Finished!';

  // Salviamo la run completata
  lastCompleteRun = JSON.parse(JSON.stringify(pointsPath));

  updateTimes(finalTime);
  attemptCount++;

  // Resetta la modalit√† Blind
  resetBlindMode();

  setTimeout(() => nextParticipant(), 1000);
}

    function calculateDistance(arr){
      let tot=0;
      for(let i=1; i<arr.length; i++){
        let dx=arr[i].x-arr[i-1].x;
        let dy=arr[i].y-arr[i-1].y;
        tot+=Math.hypot(dx,dy);
      }
      return tot;
    }
    function calculateFinalTime(ms,dist){
      const s= ms/1000;
      const penalty= PENALTY_WEIGHT*(dist/ PATH_LENGTH_SCALING);
      return 60+s+penalty;
    }
    function formatTime(sec){
      const m=Math.floor(sec/60);
      const r=(sec%60).toFixed(3);
      return `${m}'${r.replace('.', '"')}'''`;
    }

    /* TOP 5 */
    function updateTimes(t){
      const nameValue= participants[currentIndex];
      const replayData= JSON.parse(JSON.stringify(pointsPath));

      // (NEW) Salviamo anche se era Blind
      const newResult= { 
        name: nameValue, 
        time: t, 
        replay: replayData,
        blind: isBlind
      };

      bestTimes.push(newResult);
      bestTimes.sort((a,b)=>a.time-b.time);
      if(bestTimes.length>5) bestTimes.length=5;

      if(bestTimes[0].time===t){
        finalTimeOutput.classList.add('record');
        setTimeout(()=> finalTimeOutput.classList.remove('record'),2000);
      }
      updateLeaderboard();
    }

    chronoButton.addEventListener('click',()=>{
   updateLeaderboard(); // Aggiorna la lista dei migliori 5 tempi 
 updatePointsLeaderboard();  
chronoOverlay.classList.remove('hidden');
    });
    closeOverlay.addEventListener('click',()=>{
      chronoOverlay.classList.add('hidden');
    });

function updateLeaderboard() {
  const lb = document.getElementById('leaderboardList');
  lb.innerHTML = ''; // Cancella i contenuti precedenti
  bestTimes.forEach((entry, i) => {
    const li = document.createElement('li');
    const blindMark = entry.blind ? ' (B)' : ''; // Indica modalit√† Blind
    if (i === 0) {
      li.innerHTML = `${entry.name} - ${formatTime(entry.time)}${blindMark} <span style="font-size:18px;">‚èØÔ∏è</span>`;
      li.style.fontWeight = 'bold';
      li.style.cursor = 'pointer';
      li.title = "Click to watch the best replay";
      li.addEventListener('click', () => {
        chronoOverlay.classList.add('hidden');
        replayTrajectory(entry.replay);
      });
    } else {
      li.textContent = `${entry.name} - ${formatTime(entry.time)}${blindMark}`;
    }
    lb.appendChild(li);
  });
}
function updatePointsLeaderboard() {
  const tableBody = document.getElementById('pointsLeaderboardBody');
  tableBody.innerHTML = ''; // Cancella i contenuti precedenti

  // Ordina i giocatori in base ai punti
  const sortedPlayers = Object.keys(championScores).sort((a, b) => championScores[b] - championScores[a]);

  // Aggiungi ogni giocatore con i suoi punti
  sortedPlayers.forEach(player => {
    const row = document.createElement('tr');
    const nameCell = document.createElement('td');
    const pointsCell = document.createElement('td');

    nameCell.textContent = player;
    pointsCell.textContent = championScores[player];

    row.appendChild(nameCell);
    row.appendChild(pointsCell);
    tableBody.appendChild(row);
  });
}


    /* REPLAY con chiusura auto */
replayButton.addEventListener('click', () => {
  if (lastCompleteRun && lastCompleteRun.length >= 2) {
    replayTrajectory(lastCompleteRun); // Riproduce l'ultima run completata
  } else {
    statusOutput.textContent = "No run to replay! Complete a run first.";
  }
});

    function replayTrajectory(customPoints){
      const rp = (customPoints && customPoints.length>=2)
        ? customPoints : pointsPath;

      if(!rp || rp.length<2){
        statusOutput.textContent="No run to replay!";
        lastStatusMessage="No run to replay!";
        return;
      }
        // Resetta la modalit√† Blind per sicurezza
  resetBlindMode();
lastStatusMessage= statusOutput.innerHTML;

      clearCanvas();
      drawStartPoint();
      drawFinishArea();
      drawGates(gates);
      drawTrees(trees);

      let i=0;
      function step(){
        if(i>=rp.length-1){
          setTimeout(()=>{
            clearCanvas();
            if(currentTrack) drawTrack(currentTrack);
            restoreStatusOutput();
          },500);
          return;
        }
        ctx.beginPath();
        ctx.moveTo(rp[i].x, rp[i].y);
        ctx.lineTo(rp[i+1].x, rp[i+1].y);
        ctx.strokeStyle='#a4b8eb';
        ctx.lineWidth=2;
        ctx.stroke();
        const dt= rp[i+1].t- rp[i].t;
        i++;
        if(i< rp.length-1){
          setTimeout(step, dt);
        } else {
          setTimeout(step, dt);
        }
      }
      setTimeout(step,0);
    }

    /* Tasti */
    sameTrackButton.addEventListener('click',()=>{
      resetTrack(currentTrack);
      callParticipant();
    });
function resetTrack(track) {
  drawing = false;
  pointsPath = [];
  intersectedGates.clear();
  finalTimeOutput.textContent = `‚è∞1'00"000'''`;
  statusOutput.innerHTML = '';
  lastStatusMessage = '';

  // Resetta la modalit√† Blind
  resetBlindMode();

  clearCanvas();
  if (track) drawTrack(track);
}

function resetBlindMode() {
  isBlind = false; // Resetta lo stato a "non-blind"
  const blindIcon = document.getElementById('blindIcon');
  blindIcon.src = 'view.png'; // Ripristina l'immagine del pulsante
  blindIcon.alt = 'View Mode'; // Aggiorna l'attributo alt
}

    /* Logica campionato */
    function nextParticipant(){
  // Resetta la modalit√† Blind prima di passare al prossimo
  resetBlindMode();
      if(attemptCount>=3){
        attemptCount=0;
        currentIndex++;
        if(currentIndex>= participants.length){
          if(runNumber===1){
            runNumber=2;
            currentIndex=0;
            showPopup(`Starting the 2nd manche of race #${raceNumber}!`,()=>{
              resetTrack(currentTrack);
              callParticipant();
            });
          } else {
            endRace();
          }
        } else {
          const nxt=participants[currentIndex];
          showPopup(`Now it's ${nxt}'s turn!`,()=>{
            resetTrack(currentTrack);
            callParticipant();
          });
        }
      } else {
        resetTrack(currentTrack);
        callParticipant();
      }
    }

    function callParticipant(){
      let att= attemptCount+1;
      let msg= `Play <span style="color:black;">${participants[currentIndex]}</span> (G${raceNumber}/M${runNumber}/R${att})`;
      statusOutput.innerHTML= msg;
      lastStatusMessage= msg;
    }

    function endRace(){
      const sorted=[...bestTimes].sort((a,b)=> a.time-b.time);
      for(let i=0;i<5;i++){
        if(i< sorted.length){
          const entry = sorted[i];
          // Assegniamo i punti base
          championScores[ entry.name ] += CHAMPION_POINTS[i];
          // (NEW) Se la run era Blind, +3
          if(entry.blind){
            championScores[ entry.name ] += 3;
          }
        }
      }
      showRaceResults();
    }
function showRaceResults() {
  let sortedTimes = [...bestTimes].sort((a, b) => a.time - b.time);
  let html = `
    <h2>Tempi finali (Top 5)</h2>
    <div class="champ-table">
      <table>
        <tr><th>Player</th><th>Tempo</th></tr>
  `;
  sortedTimes.forEach(e => {
    const blindMark = e.blind ? ' (B)' : ''; // Aggiunge " (B)" se il tempo √® stato realizzato in modalit√† Blind
    html += `<tr><td>${e.name}</td><td>${formatTime(e.time)}${blindMark}</td></tr>`;
  });
  html += `</table></div>`;

  // Ordiniamo i giocatori in base ai punti finali (inclusi bonus da Blind fallite)
  const sortedPlayers = Object.keys(championScores)
    .sort((a, b) => championScores[b] - championScores[a]);

  // Calcoliamo i punti extra per ogni blind fallita (gi√† fatto nella fase di corsa)
  html += `
    <h2>Race Standings #${raceNumber}</h2>
    <div class="champ-table">
      <table>
        <tr><th>Player</th><th>Total Points</th></tr>
  `;
  sortedPlayers.forEach(name => {
    html += `<tr><td>${name}</td><td>${championScores[name]}</td></tr>`;
  });
  html += `</table></div>`;

  let btnLabel = "Next Race!";
  let action = () => {
    champOverlay.classList.add('hidden');
    raceNumber++;
    // invertiamo l'ordine di partenza
    participants = sortedPlayers.slice().reverse();
    setupRace();
  };
  if (raceNumber >= 3) {
    btnLabel = "Final Standings!";
    action = showFinalResults;
  }
  html += `<button class="nav-button">${btnLabel}</button>`;
  champContent.innerHTML = html;
  champContent.querySelector('.nav-button').addEventListener('click', action);
  champOverlay.classList.remove('hidden');
}


    function showFinalResults(){
      let sortedPlayers= Object.keys(championScores)
        .sort((a,b)=>championScores[b]-championScores[a]);
      const winner= sortedPlayers[0];
      let html=`
      <h2>Final Standings</h2>
      <div class="champ-table">
        <table>
          <tr><th>Player</th><th>Punti</th></tr>
      `;
      sortedPlayers.forEach(n=>{
        html+= `<tr><td>${n}</td><td>${championScores[n]}</td></tr>`;
      });
      html+= `</table></div>`;
      html+= `<h3>Wins ${winner}!!!</h3>`;
      html+= `
      <div class="end-buttons">
        <button id="btnReplayChamp">Play Again!</button>
        <button id="btnSolo">Play Solo</button>
      </div>
      `;
      champContent.innerHTML= html;

      champContent.querySelector('#btnReplayChamp').addEventListener('click',()=>{
        champOverlay.classList.add('hidden');
        slidesOverlay.classList.remove('hidden');
        currentSlideIndex=0;
        renderSlide();
      });
      champContent.querySelector('#btnSolo').addEventListener('click',()=>{
        window.location.href='index.html';
      });
      champOverlay.classList.remove('hidden');
    }

    function setupRace(){
      currentTrack= createTrackForRace(raceNumber);
      resizeCanvas();
      drawTrack(currentTrack);
      bestTimes=[];
      updateLeaderboard();
      currentIndex=0;
      attemptCount=0;
      runNumber=1;
      callParticipant();
    }

    /* Popup generico */
    function showPopup(message,onOk){
      champContent.innerHTML=`
      <h2>Attention</h2>
      <p class="slide-content">${message}</p>
      <button class="nav-button">OK</button>
      `;
      champOverlay.classList.remove('hidden');
      champContent.querySelector('.nav-button').addEventListener('click',()=>{
        champOverlay.classList.add('hidden');
        if(onOk) onOk();
        restoreStatusOutput();
      });
    }

    /* SLIDES INTRO */
    slidesIntro=[
      {
        title:"Ski-Zag Championship!‚õ∑Ô∏è",
        content:`
          Enter the players!<br>
          <div id="playersInputContainer"></div>
          <button id="addPlayerBtn" style="margin-right:8px;">Add Player</button>
          <button id="removePlayerBtn">Remove Player</button>
        `
      },
      {
        title:"Race Info üèÅ",
        content:`
          There will be 3 distinct races (Giant, Special, SuperG). Each race has 2 runs (manches), and in each run every participant has 3 consecutive attempts.
        `
      },
      {
        title:"Top 5 Scoring ‚è∞",
        content:`
          At the end of each race, the top 5 best times are awarded points (9, 7, 5, 3, 1).
        `
      },
      {
        title:"Final VictoryüèÜ",
        content:`
          At the end of the 3rd race, whoever has the most points wins the championship! Have fun!!
        `
      }
    ];

    let draftParticipants=[];

    function renderSlide(){
      slidesOverlay.classList.remove('hidden');
      const slide= slidesIntro[currentSlideIndex];
      slidesContent.innerHTML=`
        <h2 class="slide-title">${slide.title}</h2>
        <p class="slide-content">${slide.content}</p>
        <div class="tutorial-dots"></div>
        <div class="slides-nav">
          <button class="nav-button" id="btnPrev">‚Üê</button>
          <button class="nav-button" id="btnStartNow">Start!</button>
          <button class="nav-button" id="btnNext">‚Üí</button>
        </div>
      `;
      const dotsC= slidesContent.querySelector('.tutorial-dots');
      slidesIntro.forEach((s,i)=>{
        const d=document.createElement('div');
        d.className="dot"+(i===currentSlideIndex?" active":"");
        d.addEventListener('click',()=>{
          syncDraftParticipants();
          currentSlideIndex=i;
          renderSlide();
        });
        dotsC.appendChild(d);
      });

      const btnPrev= slidesContent.querySelector('#btnPrev');
      btnPrev.disabled=(currentSlideIndex===0);
      btnPrev.addEventListener('click',()=>{
        if(currentSlideIndex>0){
          syncDraftParticipants();
          currentSlideIndex--;
          renderSlide();
        }
      });

      slidesContent.querySelector('#btnStartNow').addEventListener('click',()=>{
        syncDraftParticipants();
        if(!checkDraftNames())return;
        acceptDraftParticipants();
        startChampionship();
      });

      const btnNext= slidesContent.querySelector('#btnNext');
      btnNext.disabled=(currentSlideIndex===slidesIntro.length-1);
      btnNext.addEventListener('click',()=>{
        if(currentSlideIndex<slidesIntro.length-1){
          syncDraftParticipants();
          currentSlideIndex++;
          renderSlide();
        }
      });

      if(currentSlideIndex===0){
        renderPlayersInput();
      }
    }

    function renderPlayersInput(){
      const cont= slidesContent.querySelector('#playersInputContainer');
      cont.innerHTML='';
      if(draftParticipants.length<2){
        draftParticipants=['',''];
      }
      draftParticipants.forEach(n=>{
        addPlayerField(cont,n);
      });

      slidesContent.querySelector('#addPlayerBtn').addEventListener('click',()=>{
        syncDraftParticipants();
        if(draftParticipants.length<6){
          draftParticipants.push('');
          renderSlide();
        } else {
          alert("Max 6 participants!");
        }
      });
      slidesContent.querySelector('#removePlayerBtn').addEventListener('click',()=>{
        syncDraftParticipants();
        if(draftParticipants.length>2){
          draftParticipants.pop();
          renderSlide();
        }
      });
    }
    function addPlayerField(container,def=''){
      const d=document.createElement('div');
      d.innerHTML=`
        <input type="text" class="player-name-input"
         placeholder="Player name"
         style="margin-bottom:5px;width:100%;padding:6px;border-radius:6px;border:1px solid #ccc;"
         value="${def}"
        />
      `;
      container.appendChild(d);
    }
    function syncDraftParticipants(){
      const inputs= slidesContent.querySelectorAll('.player-name-input');
      if(inputs.length===0) return; 
      draftParticipants=[];
      inputs.forEach(inp=>{
        const val= inp.value.trim();
        if(val) draftParticipants.push(val);
      });
    }
    function checkDraftNames(){
      if(draftParticipants.length<2){
        alert("At least 2 participants!");
        return false;
      }
      if(draftParticipants.length>6){
        alert("Max 6 participants!");
        return false;
      }
      const duplicates= draftParticipants.some((nm,idx)=>
        draftParticipants.indexOf(nm)!==idx
      );
      if(duplicates){
        alert("Names must be unique!");
        return false;
      }
      return true;
    }
    function acceptDraftParticipants(){
      participants=[...draftParticipants];
    }
    function startChampionship(){
      championScores={};
      participants.forEach(p=> championScores[p]=0);
      slidesOverlay.classList.add('hidden');
      raceNumber=1;
      runNumber=1;
      setupRace();
    }

  document.addEventListener('DOMContentLoaded', () => {
  resizeCanvas();
  renderSlide();

  // Assicurati che la modalit√† Blind sia disattivata all'inizio
  resetBlindMode();
});

  </script>
</body>
</html>
