<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <!-- Disabilita pinch-to-zoom / doppio tap -->
  <meta name="viewport" content="width=300, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <title>Ski Championship</title>
  <style>
    /* (stili invariati) */
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: "Helvetica Neue", Arial, sans-serif;
      background: #ffffff;
    }
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .container {
      position: relative;
      width: 300px;
      height: 520px;
      /* Sfondo immagine */
      background: #e1dffc url("sfondo.png") no-repeat center center;
      background-size: cover;
      border: 2px solid #ffffff;
      border-radius: 10px;
      margin-top: 20px;
      box-sizing: border-box;
      overflow: hidden;
    }
    canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      cursor: crosshair;
    }
    /* Nuovo canvas per l'effetto neve */
    #snowCanvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 10;
    }
    button {
      border: none;
      background: none;
      cursor: pointer;
      font-size: 18px;
      margin: 0;
      padding: 0;
      color: black;
  z-index: 20;
    }
    /* CSS per il bottone blind */
    #blindToggle {
      font-size: 18px;
      padding: 5px 8px;
      position: absolute;
      bottom: 3px;
      left: 272px; /* Posizionato a sinistra del bottone alberi */
      transform: translateX(-50%);
      cursor: pointer;
    }
    button:hover { opacity: 0.7; }
    #sameTrack { position: absolute; bottom: 10px; left: 10px; }
    #replayButton { position: absolute; bottom: 10px; left: 10px; }
    #quit { position: absolute; top: 10px; left: 10px; }
    #chronoButton { position: absolute; top: 10px; right: 10px; }
    #addPlayerBtn, #removePlayerBtn { font-size: 12px; }
    .info-container {
      margin-top: 13px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    #finalTimeOutput { margin: -10px 0; font-weight: bold; }
    #statusOutput { margin: 15px 0; font-weight: bold; color: red; min-height: 20px; }
    @keyframes blink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0; }
    }
    .record { animation: blink 0.5s ease-in-out 3; }
    .overlay {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background-color: rgba(0, 0, 0, 0.7);
      z-index: 9999;
      display: flex; justify-content: center; align-items: center;
      animation: fadeIn 0.3s ease;
    }
    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
    .hidden { display: none; }
    .overlay-content {
      background-image: url('backpopup.png');
  background-repeat: no-repeat;
  background-position: center;
  background-size: cover; /* Oppure "contain" se preferisci che l'intera immagine sia visibile */
  background-color: #fff; /* Colore di fallback se l'immagine non viene caricata */
      border-radius: 12px;
      padding: 20px;
      width: 280px;
      max-width: none;
      box-sizing: border-box;
      position: relative; text-align: center; color: #333;
 box-shadow: 
    inset 4px 4px 2px rgba(175,219,245,0.8),  /* Ombra interna scura in basso a destra */
    inset -4px -4px 2px rgba(255,255,255,0.8); /* Ombra interna chiara in alto a sinistra */
}
    }
    #chronoOverlay .overlay-content { max-width: 700px; }
    #closeOverlay { position: absolute; top: 10px; left: 10px; background-color: #dc3545; font-size: 14px; padding: 5px 10px; color: white; border: none; border-radius: 5px; cursor: pointer; }
    #closeOverlay:hover { background-color: #c82333; }
    .leaderboard-container { display: block; width: 100%; margin-top: 10px; }
    .leaderboard { width: 80%; margin: 0 auto; }
    .leaderboard h2 { text-align: center; margin: 10px 0; }
    ol { border: 1px solid #ccc; border-radius: 5px; list-style: decimal inside; min-height: 100px; padding: 10px; margin: 0; }
    li { padding: 5px 0; }
    .intro-overlay { }
    .slide-content { margin-bottom: 20px; line-height: 1.4; }
    .slide-title { margin-top: 0; margin-bottom: 10px; font-size: 22px; }
    .slides-nav { display: flex; justify-content: space-between; align-items: center; margin-top: 15px; }
    .slides-nav .nav-button { background: #007bff; color: #fff; border: none; border-radius: 8px; padding: 8px 14px; font-size: 14px; cursor: pointer; }
    .slides-nav .nav-button:disabled { background: #999; cursor: not-allowed; }
    .tutorial-dots { display: flex; justify-content: center; gap: 8px; margin: 10px 0; }
    .dot { width: 10px; height: 10px; border-radius: 50%; background: #ccc; cursor: pointer; transition: background 0.3s; }
    .dot.active { background: #007bff; }
    .champ-table { margin: 15px 0; border: 1px solid #ccc; border-radius: 8px; width: 100%; overflow: hidden; text-align: left; }
    .champ-table table { width: 100%; border-collapse: collapse; }
    .champ-table th, .champ-table td { padding: 8px; border-bottom: 1px solid #eee; }
    .champ-table th { background: #f7f7f7; font-weight: bold; }
    .champ-table tr:last-child td { border-bottom: none; }
    .end-buttons { display: flex; justify-content: center; gap: 10px; margin-top: 20px; }
    .end-buttons button { background: #007bff; color: #fff; border: none; border-radius: 8px; padding: 8px 14px; font-size: 14px; cursor: pointer; }
    .end-buttons button:hover { background-color: #0056b3; }
  </style>
</head>
<body>
  <!-- Calibrazione -->
  <div id="calibrationTest" style="width:1in; position:absolute; left:-1000px; top:-1000px;"></div>
  
  <div class="container">
    <canvas id="canvas"></canvas>
    <!-- Nuovo canvas per l'effetto neve -->
    <canvas id="snowCanvas" class="hidden"></canvas>
    
    <!-- Bottoni di controllo -->
  <button id="sameTrack" title="Same Run" hidden>üîÅ</button>
    <button id="replayButton" title="Replay">
  <img src="replay.png" alt="Replay" style="width: 20px; height: 20px;">
</button>
    <button id="chronoButton" title="Chrono">
      <img src="stopwatch.png" alt="Chrono" style="width:20px; height:20px;">
    </button>
   <button id="quit" title="Close">
  <img src="close.png" alt="Close" style="width:18px; height:18px;">
</button>
    <!-- Bottone per Blind Mode -->
    <button id="blindToggle" title="Toggle Blind Mode">
      <img id="blindIcon" src="view.png" alt="View Mode" style="width:24px; height:24px;">
    </button>
    
    <!-- Overlay CHRONO (Top 5) -->
    <div id="chronoOverlay" class="overlay hidden">
      <div class="overlay-content">
        <button id="closeOverlay">X</button>
        <div class="leaderboard-container">
          <div class="leaderboard">
            <h2>Top 5</h2>
            <ol id="leaderboardList"></ol>
          </div>
        </div>
        <!-- Sezione Classifica Punti -->
        <div class="leaderboard-container">
          <div class="leaderboard">
            <h2>Classifica Punti</h2>
            <div class="champ-table">
              <table id="pointsLeaderboardTable">
                <thead>
                  <tr>
                    <th>Player</th>
                    <th>Punti</th>
                  </tr>
                </thead>
                <tbody id="pointsLeaderboardBody">
                  <!-- Dati inseriti dinamicamente -->
                </tbody>
              </table>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
  
  <div class="info-container">
    <p id="finalTimeOutput">‚è∞1'00"000'''</p>
    <p id="statusOutput"></p>
  </div>
  
  <!-- OVERLAY INTRO E SLIDES -->
  <div id="slidesOverlay" class="overlay hidden">
    <div id="slidesContent" class="overlay-content intro-overlay"></div>
  </div>
  
  <!-- OVERLAY ANNUNCI E CLASSIFICHE -->
  <div id="champOverlay" class="overlay hidden">
    <div id="champContent" class="overlay-content"></div>
  </div>
  
  <script>
    /* ==============================================
       VARIABILI GLOBALI
    ============================================== */
    const PATH_LENGTH_SCALING = 500;
    const PENALTY_WEIGHT      = 0.5;
const BORDER_THRESHOLD = 5; // Considera "al bordo" se la traiettoria sta entro 1px dal limite del canvas.

    
    const canvas           = document.getElementById('canvas');
    const ctx              = canvas.getContext('2d');
    const finalTimeOutput  = document.getElementById('finalTimeOutput');
    const statusOutput     = document.getElementById('statusOutput');
    const sameTrackButton  = document.getElementById('sameTrack');
    const replayButton     = document.getElementById('replayButton');
    const chronoButton     = document.getElementById('chronoButton');
    const chronoOverlay    = document.getElementById('chronoOverlay');
    const closeOverlay     = document.getElementById('closeOverlay');
    const slidesOverlay    = document.getElementById('slidesOverlay');
    const slidesContent    = document.getElementById('slidesContent');
    const champOverlay     = document.getElementById('champOverlay');
    const champContent     = document.getElementById('champContent');
    
    // Variabili di gioco e stato
    let bestTimes        = [];
    let currentTrack     = null;
    let gates            = [];
    let trees            = [];
    let pointsPath       = [];
    let drawing          = false;
    let startTime        = 0;
    let intersectedGates = new Set();
    let participants     = [];
    let championScores   = {};
    let currentIndex     = 0;
    let attemptCount     = 0;
    let raceNumber       = 1;
    let runNumber        = 1;
    const CHAMPION_POINTS= [9,7,5,3,1];
    let hardMode         = true;
    let slidesIntro      = [];
    let currentSlideIndex= 0;
    let didFinishOrFailThisRun = false;
    let lastStatusMessage = '';
    let lastCompleteRun   = null;
    let falseStartCount   = 0;
    let weatherState      = null;  // "nn", "pn", "mn", "nf"
    let snowIntensity     = 0;     // Intensit√† neve
    let showSnow          = false;   // Flag effetto neve
    let globalWind = Math.random() * 1 - 0.5;
let replaySnowState = false; // Per memorizzare lo stato della neve
    // Nuova variabile per gestire i colpi con l'albero
    let treeHits = {}; // Es.: treeHits["Mario"] = numero di impatti consecutivi
    
    // Impostazioni canvas e coordinate di partenza/arrivo
    let startPoint = { x:150, y:30 };
    let finishRect = { x:130, y:490, width:40, height:10 };
    let lastSnowActive = false;
let outPenaltyCount = 0; // Conta quante volte la traiettoria esce dal campo
let isOut = false;       // Flag per rilevare quando si esce ed evitare conteggi multipli continui
// Funzione di interpolazione: controlla se tra p1 e p2 viene "toccatto" il bordo
function checkInterpolationForBorder(p1, p2) {
  const stepLength = 2;  // Lunghezza del passo in pixel
  const dx = p2.x - p1.x;
  const dy = p2.y - p1.y;
  const distance = Math.hypot(dx, dy);
  const steps = Math.ceil(distance / stepLength);
  
  // Interpola tra p1 e p2
  for (let i = 1; i <= steps; i++) {
    const t = i / steps;
    const ix = p1.x + t * dx;
    const iy = p1.y + t * dy;
    if (ix < BORDER_THRESHOLD || ix > canvas.width - BORDER_THRESHOLD ||
        iy < BORDER_THRESHOLD || iy > canvas.height - BORDER_THRESHOLD) {
      return true;
    }
  }
  return false;
}

    function resizeCanvas(){
      canvas.width = 300;
      canvas.height = 520;
      startPoint = { x: canvas.width/2, y:30 };
      finishRect = { x: (canvas.width/2)-20, y: canvas.height-30, width:40, height:10 };
      // Aggiorna anche il canvas neve
      const snowCanvas = document.getElementById('snowCanvas');
      snowCanvas.width = canvas.width;
      snowCanvas.height = canvas.height;
    }
    
    function clearCanvas(){
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    }
    
    /* =======================================
       Calibrazione
    ======================================= */
    window.addEventListener('load', () => {
      const cal = document.getElementById('calibrationTest');
      window.conversionFactor = cal.offsetWidth / 96;
    });
    
    /* =======================================
       Impostazione delle icone e risorse
    ===================================== */
    const gateIcons = {
      red: new Image(),
      blue: new Image()
    };
    gateIcons.red.src = "red_gate.svg";
    gateIcons.blue.src = "blue_gate.svg";
    
    /* =======================================
       Funzioni Meteo (unificate)
    ===================================== */
    function chooseWeatherState(prevState) {
      const r = Math.random() * 100;
      switch (prevState) {
        case "nn":
          if (r < 50) return "nn";
          else if (r < 80) return "pn";
          else if (r < 95) return "mn";
          else return "nf";
        case "pn":
          if (r < 25) return "nn";
          else if (r < 65) return "pn";
          else if (r < 90) return "mn";
          else return "nf";
        case "mn":
          if (r < 20) return "nn";
          else if (r < 50) return "pn";
          else if (r < 80) return "mn";
          else return "nf";
        case "nf":
          if (r < 20) return "nn";
          else if (r < 60) return "pn";
          else if (r < 80) return "mn";
          else return "nf";
        default:
          return "nn";
      }
    }
    
    function applyWeatherState(state) {
      if (state === "nn") {
        snowIntensity = 0;
      } else if (state === "pn") {
        snowIntensity = 300;
      } else if (state === "mn") {
        snowIntensity = 1000;
      } else if (state === "nf") {
        snowIntensity = 3250;
      }
      weatherState = state;
      return snowIntensity > 0;
    }
    
    /* =======================================
       Sistema neve: inizializza e aggiorna le particelle
    ===================================== */
    const container = document.querySelector('.container');
    let snowCanvas = document.getElementById('snowCanvas');
    const snowCtx = snowCanvas.getContext('2d');
    let snowflakes = [];
    
    function initSnow(){
      snowflakes = [];
      for (let i = 0; i < snowIntensity; i++){
        snowflakes.push({
          x: Math.random() * snowCanvas.width,
          y: Math.random() * snowCanvas.height,
          radius: Math.random() * 3 + 1,
          speedY: Math.random() * 0.5 + 0.5,
          speedX: (Math.random() * 0.5) - 0.25
        });
      }
    }
    
    function updateSnow(){
      if (!showSnow) return;
      snowCtx.clearRect(0, 0, snowCanvas.width, snowCanvas.height);
      snowflakes.forEach(flake => {
        flake.x += flake.speedX + globalWind;
        flake.y += flake.speedY;
        if (flake.y > snowCanvas.height) {
          flake.y = 0;
          flake.x = Math.random() * snowCanvas.width;
        }
        if (flake.x > snowCanvas.width) flake.x = 0;
        if (flake.x < 0) flake.x = snowCanvas.width;
        snowCtx.beginPath();
        snowCtx.arc(flake.x, flake.y, flake.radius, 0, Math.PI * 2);
        snowCtx.fillStyle = 'white';
        snowCtx.fill();
      });
      requestAnimationFrame(updateSnow);
    }
    
    /* =======================================
       Generazione della Pista
    ===================================== */
    function createTrackForRace(rn){
      let gc = 8;
      if(rn === 2) gc = 10;
      if(rn === 3) gc = 6;
      const g = generateGates(gc);
      const t = generateTrees(g);
      return { gates: g, trees: t };
    }
    
    function generateGates(count){
      const startWithRed = (Math.random() < 0.5);
      let isRed = startWithRed;
      let arr = [];
      for(let i = 0; i < count; i++){
        const dir = isRed ? 1 : -1;
        const x   = isRed 
          ? Math.random() * (canvas.width/2 - 35) + canvas.width/2
          : Math.random() * (canvas.width/2 - 35) + 35;
        const y   = 60 + i * ((canvas.height-120) / count);
        const color = isRed ? 'red' : 'blue';
        arr.push({
          x, y, color,
          line: { x1: x, y1: y, x2: x + dir * 200, y2: y }
        });
        isRed = !isRed;
      }
      return arr;
    }
    
    function generateTrees(gArr){
      const treeCount = Math.floor(Math.random() * 3) + 6;
      let arr = [];
      const margin = 15;
      const minGate = 50, minTree = 30, minFinish = 50, minStart = 20, minTop = 30;
      while(arr.length < treeCount){
        const tx = margin + Math.random() * (canvas.width - 2 * margin);
        const ty = minTop + Math.random() * (canvas.height - minTop - margin);
        const closeGate = gArr.some(g => Math.hypot(tx - g.x, ty - g.y) < minGate);
        const closeTrees = arr.some(t => Math.hypot(tx - t.x, ty - t.y) < minTree);
        const closeFinish = isNearFinish(tx, ty, finishRect, minFinish);
        const closeStart = Math.hypot(tx - startPoint.x, ty - startPoint.y) < minStart;
        if(!closeGate && !closeTrees && !closeFinish && !closeStart){
          arr.push({ x: tx, y: ty });
        }
      }
      return arr;
    }
    
    /* =======================================
       Disegno della Pista e degli Elementi
    ===================================== */
    function drawTrack(track){
      clearCanvas();
      gates = track.gates;
      trees = track.trees;
      drawStartPoint();
      drawFinishArea();
      drawGates(gates);
      drawTrees(trees);
    }
    
    function drawStartPoint(){
      ctx.font = '18px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('üè†', startPoint.x, startPoint.y);
    }
    
    function drawFinishArea(){
      const { x, y, width, height } = finishRect;
      const sq = width / 8;
      const rowCount = Math.floor(height / (width / 8));
      for(let row = 0; row < rowCount; row++){
        for(let col = 0; col < 8; col++){
          ctx.fillStyle = ((row+col) % 2 === 0) ? 'black' : '#F0F0F0';
          ctx.fillRect(x + col*sq, y + row*sq, sq, sq);
        }
      }
    }
    
    function drawGates(gArr){
      gArr.forEach(g => {
        const icon = g.color === "red" ? gateIcons.red : gateIcons.blue;
        const iconWidth = 16;
        const iconHeight = 16;
        ctx.drawImage(icon, g.x - iconWidth/2, g.y - iconHeight/2, iconWidth, iconHeight);
      });
    }
    
    function drawTrees(tArr){
      const treeImg = new Image();
      treeImg.src = './tree.svg';
      treeImg.onload = () => {
        tArr.forEach(t => {
          // Disegno con offset: l'immagine viene disegnata a t.x-6, t.y-20, dimensione 12x20
          ctx.drawImage(treeImg, t.x - 6, t.y - 20, 12, 20);
        });
      };
    }
    
    /* =======================================
       Eventi Mouse / Touch (unificati)
    ===================================== */
    if(!canvas._eventsAttached){
      canvas.addEventListener('mousedown', handleMouseDown);
      canvas.addEventListener('mousemove', handleMouseMove);
      canvas.addEventListener('mouseup', handleMouseUp);
      canvas.addEventListener('touchstart', handleTouchStart);
      canvas.addEventListener('touchmove', handleTouchMove);
      canvas.addEventListener('touchend', handleTouchEnd);
      canvas._eventsAttached = true;
    }
    
    function getMouseCoords(e){
      const rect = canvas.getBoundingClientRect();
      const cx = (e.touches) ? e.touches[0].clientX : e.clientX;
      const cy = (e.touches) ? e.touches[0].clientY : e.clientY;
      return { x: cx - rect.left, y: cy - rect.top };
    }
    
    function isNearStartPoint(x,y){
      return (Math.hypot(x - startPoint.x, y - startPoint.y) <= 20);
    }
    
function handleMouseDown(e){
  const { x, y } = getMouseCoords(e);
  if(!isNearStartPoint(x, y)){
    falseStartCount++;  // Incrementa il contatore degli errori

    if(falseStartCount === 1) {
      statusOutput.innerHTML = '<span style="color:red;">False start!</span> <span style="color:black;">2nd attempt!</span>';
      setTimeout(() => {
        restoreStatusOutput();
      }, 1000); // Il messaggio resta per 1 secondo
    } else if(falseStartCount === 2) {
      statusOutput.innerHTML = '<span style="color:red;">False start!</span> <span style="color:black;">Last attempt!</span>';
      setTimeout(() => {
        restoreStatusOutput();
      }, 1000);
    } else if(falseStartCount >= 3){
      statusOutput.textContent = 'Run failed due to consecutive false starts!';
      failAttempt("Run failed due to false starts.");
      falseStartCount = 0;  // Reset dopo il fallimento
    }
    return;
  }
  // Se il punto di partenza √® corretto, resettiamo il conteggio
  falseStartCount = 0;

  // Resettiamo le variabili per la penalit√† "uscita dal campo"
  outPenaltyCount = 0;
  isOut = false;

  drawing = true;
  pointsPath = [];
  startTime = performance.now();
  statusOutput.textContent = '';
  lastStatusMessage = '';
  ctx.beginPath();
  pointsPath.push({ x, y, t: 0 });
  ctx.moveTo(x, y);
  didFinishOrFailThisRun = false;
}


function handleMouseMove(e){
  if(!drawing) return;
  const { x, y } = getMouseCoords(e);
  
  // Preleva l'ultimo punto registrato (se esiste)
  let p1 = pointsPath[pointsPath.length - 1];
  let p2 = { x, y };

  // Usa l'interpolazione per verificare se il segmento attraversa il bordo
  if (p1 && checkInterpolationForBorder(p1, p2)) {
    if(!isOut) {  // Se non √® gi√† stato segnato come "al bordo"
      outPenaltyCount++; // Incrementa la penalit√†
      isOut = true;
    }
  } else {
    isOut = false;
  }

  // Registra il nuovo punto con il tempo relativo
  const now = performance.now() - startTime;
  pointsPath.push({ x, y, t: now });
  
  if(!isBlind){
    ctx.lineTo(x, y);
    ctx.strokeStyle = '#a4b8eb';
    ctx.lineWidth = 2;
    ctx.stroke();
  }
  checkIntersections();
}
    
    function handleMouseUp(e){
      if(!drawing) return;
      drawing = false;
      if(!didFinishOrFailThisRun){
        failAttempt("Run interrupted!");
      }
    }
    
function handleTouchStart(e){
  e.preventDefault();
  const { x, y } = getMouseCoords(e);
  if(!isNearStartPoint(x,y)){
    statusOutput.textContent = 'You must start from the start point!';
    return;
  }
  
  // Reset delle variabili per la penalit√† "uscita dal campo"
  outPenaltyCount = 0;
  isOut = false;
  
  drawing = true;
  pointsPath = [];
  startTime = performance.now();
  statusOutput.textContent = '';
  lastStatusMessage = '';
  ctx.beginPath();
  pointsPath.push({ x, y, t: 0 });
  ctx.moveTo(x, y);
  didFinishOrFailThisRun = false;
}

    
function handleTouchMove(e){
  e.preventDefault();
  if(!drawing) return;
  const { x, y } = getMouseCoords(e);

  let p1 = pointsPath[pointsPath.length - 1];
  let p2 = { x, y };

  // Utilizza la funzione di interpolazione per controllare il contatto con il bordo
  if (p1 && checkInterpolationForBorder(p1, p2)) {
    if(!isOut) {
      outPenaltyCount++;
      isOut = true;
    }
  } else {
    isOut = false;
  }
  
  const now = performance.now() - startTime;
  pointsPath.push({ x, y, t: now });
  
  if(!isBlind){
    ctx.lineTo(x, y);
    ctx.strokeStyle = '#a4b8eb';
    ctx.lineWidth = 2;
    ctx.stroke();
  }
  checkIntersections();
}

    
    function handleTouchEnd(e){
      e.preventDefault();
      if(!drawing) return;
      drawing = false;
      if(!didFinishOrFailThisRun){
        failAttempt("Run interrupted!");
      }
    }
    
    function checkIntersections(){
      for(let i = 1; i < pointsPath.length; i++){
        const p1 = pointsPath[i-1], p2 = pointsPath[i];
        if(hardMode){
          for(const tree of trees){
            const steps = Math.ceil(Math.hypot(p2.x-p1.x, p2.y-p1.y) / 5);
            for(let j = 0; j <= steps; j++){
              const ix = p1.x + (p2.x-p1.x) * (j/steps);
              const iy = p1.y + (p2.y-p1.y) * (j/steps);
              // Per l'immagine dell'albero, il disegno usa un offset: l'icona √® disegnata in (tree.x-6, tree.y-20)
              // Il centro visivo √® dunque (tree.x, tree.y-10)
              const dist = Math.hypot(ix - tree.x, iy - (tree.y - 10));
              if(dist < 10){
                // Registra il colpo dell'albero per il giocatore attuale
                let currentPlayer = participants[currentIndex];
                if (!treeHits[currentPlayer]) {
                  treeHits[currentPlayer] = 1;
                } else {
                  treeHits[currentPlayer]++;
                }
                failAttempt("You hit a tree!");
                return;
              }
            }
          }
        }
        for(const [idx, gate] of gates.entries()){
          if(linesIntersect(p1.x, p1.y, p2.x, p2.y, gate.line.x1, gate.line.y1, gate.line.x2, gate.line.y2)){
            intersectedGates.add(idx);
          }
        }
        if(isSegmentInFinishArea(p1, p2, finishRect)){
          if(intersectedGates.size === gates.length){
            finishRun();
          } else {
            failAttempt("You missed a gate!");
          }
          return;
        }
      }
    }
    
    function linesIntersect(x1, y1, x2, y2, x3, y3, x4, y4){
      const det = (x2 - x1) * (y4 - y3) - (y2 - y1) * (x4 - x3);
      if(det === 0) return false;
      const lambda = ((y4 - y3) * (x4 - x1) + (x3 - x4) * (y4 - y1)) / det;
      const gamma  = ((y1 - y2) * (x4 - x1) + (x2 - x1) * (y4 - y1)) / det;
      return (lambda >= 0 && lambda <= 1 && gamma >= 0 && gamma <= 1);
    }
    
    function isSegmentInFinishArea(p1, p2, rect){
      if((p1.y < rect.y && p2.y < rect.y) || (p1.y > rect.y + rect.height && p2.y > rect.y + rect.height))
        return false;
      if((p1.x < rect.x && p2.x < rect.x) || (p1.x > rect.x + rect.width && p2.x > rect.x + rect.width))
        return false;
      return true;
    }
    
    function isNearFinish(x, y, rect, minD){
      return (
        x >= rect.x - minD &&
        x <= rect.x + rect.width + minD &&
        y >= rect.y - minD &&
        y <= rect.y + rect.height + minD
      );
    }
    
    /* =======================================
       Gestione dei Tentativi
    ===================================== */
function failAttempt(msg) {
  drawing = false;
  didFinishOrFailThisRun = true;

  // Salva il percorso della run non conclusa
  if (pointsPath.length > 0) {
    lastCompleteRun = JSON.parse(JSON.stringify(pointsPath)); // Salva il percorso corrente
  }

  // Se stiamo giocando in modalit√† blind, assegniamo +3 punti agli altri giocatori
  if (isBlind) {
    statusOutput.textContent = "Blind failed! Penalty!";
    for (let player in championScores) {
      if (player !== participants[currentIndex]) {
        championScores[player] += 3;
      }
    }
    updatePointsLeaderboard();
  } else {
    statusOutput.textContent = msg;
  }

  lastStatusMessage = statusOutput.textContent;
  attemptCount++;
  setTimeout(() => nextParticipant(), 2000);
}

function finishRun(){
  drawing = false;
  didFinishOrFailThisRun = true;
  const endTime = performance.now();
  const elapsedTime = endTime - startTime;
  const distPx = calculateDistance(pointsPath);
  const realLength = distPx * (window.conversionFactor || 1);
  
  // Calcola il tempo base
  let baseTime = calculateFinalTime(elapsedTime, realLength);
  
  // Penalit√† per alberi (gi√† esistente)
  let currentPlayer = participants[currentIndex];
  let extraPenalty = 0;
  if (treeHits[currentPlayer]) {
    extraPenalty = 0.02 * Math.pow(2, treeHits[currentPlayer] - 1);
    
  }
  
  // Nuova penalit√†: per ogni uscita dal campo, +0.10 secondi
  let outPenaltyTotal = outPenaltyCount * 0.10;
  
  // Calcola il tempo finale sommando le penalit√†
  const finalTime = baseTime + extraPenalty + outPenaltyTotal;
  
  // Visualizza il tempo finale e mostra la penalit√† tra parentesi (se presente)
  finalTimeOutput.textContent = `‚è∞ ${formatTime(finalTime)}${(outPenaltyTotal > 0) ? `(+${outPenaltyTotal.toFixed(2)})` : ""}`;
  statusOutput.textContent = 'Finished!';
  lastStatusMessage = 'Finished!';
  
  // Salva il percorso per il replay
  lastCompleteRun = JSON.parse(JSON.stringify(pointsPath));
  
  // Salva lo stato della neve
  lastSnowActive = showSnow;
  
  updateTimes(finalTime);
  attemptCount++;
  resetBlindMode();
  setTimeout(() => nextParticipant(), 2500);
}


    function calculateDistance(arr){
      let tot = 0;
      for(let i = 1; i < arr.length; i++){
        let dx = arr[i].x - arr[i-1].x;
        let dy = arr[i].y - arr[i-1].y;
        tot += Math.hypot(dx, dy);
      }
      return tot;
    }
    
    function calculateFinalTime(ms, dist){
      const s = ms / 1000;
      const penalty = PENALTY_WEIGHT * (dist / PATH_LENGTH_SCALING);
      return 60 + s + penalty;
    }
    
    function formatTime(sec){
      const m = Math.floor(sec / 60);
      const r = (sec % 60).toFixed(3);
      return `${m}'${r.replace('.', '"')}'''`;
    }
    
    /* =======================================
       Aggiornamento Leaderboard e Punteggi
    ===================================== */
    function updateTimes(t){
      const nameValue = participants[currentIndex];
      const replayData = JSON.parse(JSON.stringify(pointsPath));
      const newResult = {
        name: nameValue,
        time: t,
        replay: replayData,
        blind: isBlind
      };
      bestTimes.push(newResult);
      bestTimes.sort((a, b) => a.time - b.time);
      if(bestTimes.length > 5) bestTimes.length = 5;
      if(bestTimes[0].time === t){
        finalTimeOutput.classList.add('record');
        setTimeout(() => finalTimeOutput.classList.remove('record'), 2000);
      }
      updateLeaderboard();
    }
    
    chronoButton.addEventListener('click', () => {
      updateLeaderboard();
      updatePointsLeaderboard();
      chronoOverlay.classList.remove('hidden');
    });
    
    closeOverlay.addEventListener('click', () => {
      chronoOverlay.classList.add('hidden');
    });
    
    function updateLeaderboard(){
      const lb = document.getElementById('leaderboardList');
      lb.innerHTML = '';
      bestTimes.forEach((entry, i) => {
        const li = document.createElement('li');
        const blindMark = entry.blind ? ' (B)' : '';
        if(i === 0){
          li.innerHTML = `${entry.name} - ${formatTime(entry.time)}${blindMark} <span style="font-size:18px;">‚èØÔ∏è</span>`;
          li.style.fontWeight = 'bold';
          li.style.cursor = 'pointer';
          li.title = "Click to watch the best replay";
          li.addEventListener('click', () => {
            chronoOverlay.classList.add('hidden');
            replayTrajectory(entry.replay);
          });
        } else {
          li.textContent = `${entry.name} - ${formatTime(entry.time)}${blindMark}`;
        }
        lb.appendChild(li);
      });
    }
    
    function updatePointsLeaderboard(){
      const tableBody = document.getElementById('pointsLeaderboardBody');
      tableBody.innerHTML = '';
      const sortedPlayers = Object.keys(championScores).sort((a, b) => championScores[b] - championScores[a]);
      sortedPlayers.forEach(player => {
        const row = document.createElement('tr');
        const nameCell = document.createElement('td');
        const pointsCell = document.createElement('td');
        nameCell.textContent = player;
        pointsCell.textContent = championScores[player];
        row.appendChild(nameCell);
        row.appendChild(pointsCell);
        tableBody.appendChild(row);
      });
    }
    
    /* =======================================
       REPLAY della Traiettoria
    ===================================== */
replayButton.addEventListener('click', () => {
  if (lastCompleteRun && lastCompleteRun.length >= 2) {
    replayTrajectory(lastCompleteRun);
  } else {
    statusOutput.textContent = "No run to replay!";
    setTimeout(() => {
      restoreStatusOutput();
    }, 2000); // 2000 millisecondi = 2 secondi
  }
});
    
 function replayTrajectory(customPoints) {
  const rp = (customPoints && customPoints.length >= 2)
    ? customPoints : pointsPath;
  if (!rp || rp.length < 2) {
    statusOutput.textContent = "No run to replay!";
    lastStatusMessage = "No run to replay!";
    
    // Ripristina il messaggio di stato dopo 2 secondi
    setTimeout(() => {
      restoreStatusOutput();
    }, 1000);
    
    return;
  }

  // Salva lo stato della neve prima del replay
  const preReplaySnowState = showSnow;

  // Riattiva la neve se era attiva durante la corsa
  if (lastSnowActive) {
    showSnow = true;
    const snowCanvas = document.getElementById('snowCanvas');
    snowCanvas.classList.remove('hidden');
    snowCanvas.width = canvas.width;
    snowCanvas.height = canvas.height;
    initSnow();
    updateSnow();
  } else {
    document.getElementById('snowCanvas').classList.add('hidden');
  }

  lastStatusMessage = statusOutput.innerHTML;
  clearCanvas();
  drawStartPoint();
  drawFinishArea();
  drawGates(gates);
  drawTrees(trees);
  let i = 0;

  function step() {
    if (i >= rp.length - 1) {
      setTimeout(() => {
        clearCanvas();
        if (currentTrack) drawTrack(currentTrack);

        // Ripristina lo stato della neve originale
        if (preReplaySnowState) {
          showSnow = true;
          const snowCanvas = document.getElementById('snowCanvas');
          snowCanvas.classList.remove('hidden');
          snowCanvas.width = canvas.width;
          snowCanvas.height = canvas.height;
          initSnow();
          updateSnow();
        } else {
          showSnow = false;
          document.getElementById('snowCanvas').classList.add('hidden');
        }

        restoreStatusOutput();
      }, 500);
      return;
    }

    ctx.beginPath();
    ctx.moveTo(rp[i].x, rp[i].y);
    ctx.lineTo(rp[i + 1].x, rp[i + 1].y);
    ctx.strokeStyle = '#a4b8eb';
    ctx.lineWidth = 2;
    ctx.stroke();
    const dt = rp[i + 1].t - rp[i].t;
    i++;
    setTimeout(step, dt);
  }
  
  setTimeout(step, 0);
}


    
 function restoreStatusOutput(){
    if(!champOverlay.classList.contains('hidden')){
        return;
    }
    // Se lastStatusMessage √® "No run to replay!", ripristina lo stato di gioco
    if (lastStatusMessage === "No run to replay!") {
        statusOutput.innerHTML = `Play ${participants[currentIndex]} (G${raceNumber}/M${runNumber}/R${attemptCount + 1})`;
    } else {
        statusOutput.innerHTML = lastStatusMessage || '';
    }
}
    
    /* =======================================
       Blind Mode
    ===================================== */
    const blindToggleButton = document.getElementById('blindToggle');
    let isBlind = false;
    blindToggleButton.addEventListener('click', () => {
      isBlind = !isBlind;
      const blindIcon = document.getElementById('blindIcon');
      if (isBlind) {
        blindIcon.src = 'hide.png'; // occhio chiuso
        blindIcon.alt = 'Hide Mode';
      } else {
        blindIcon.src = 'view.png'; // occhio aperto
        blindIcon.alt = 'View Mode';
      }
    });
    
    function resetBlindMode(){
      isBlind = false;
      const blindIcon = document.getElementById('blindIcon');
      blindIcon.src = 'view.png';
      blindIcon.alt = 'View Mode';
    }
    
    /* =======================================
       Gestione Discesa, Manche e Gara
    ===================================== */
    function nextParticipant(){
      resetBlindMode();
      if(attemptCount >= 3){
        attemptCount = 0;
        currentIndex++;
        if(currentIndex >= participants.length){
          if(runNumber === 1){
            runNumber = 2;
            currentIndex = 0;
            showPopup(`Starting the 2nd manche of race #${raceNumber}!`, () => {
              resetTrack(currentTrack);
              callParticipant();
            });
          } else {
            endRace();
          }
        } else {
          const nxt = participants[currentIndex];
          showPopup(`Now it's ${nxt}'s turn!`, () => {
            resetTrack(currentTrack);
            callParticipant();
          });
        }
      } else {
        resetTrack(currentTrack);
        callParticipant();
      }
    }
    
function callParticipant(){
  let att = attemptCount + 1;
  let currentPlayer = participants[currentIndex];
  let penaltyDisplay = "";
  if (treeHits[currentPlayer]) {
    // Calcola il penalty in secondi:
    let penaltyVal = 0.02 * Math.pow(2, treeHits[currentPlayer] - 1); 
    // Formatta il valore con 2 decimali, es. "0.02s"
    penaltyDisplay = `/+${penaltyVal.toFixed(2)}s`;
  }
let msg = `<span style="color:black;">${currentPlayer}</span> (
  #<span style="color:black;">${raceNumber}</span>/
  M<span style="color:black;">${runNumber}</span>/
  Run<span style="color:black;">${att}</span>${penaltyDisplay}
)`;
  statusOutput.innerHTML = msg;
  lastStatusMessage = msg;
  
  // Rivaluta il meteo all'inizio di ogni discesa
  let newWeatherState = chooseWeatherState(weatherState);
  showSnow = applyWeatherState(newWeatherState);
  
  const snowCanvas = document.getElementById('snowCanvas');
  if (showSnow) {
      snowCanvas.classList.remove('hidden');
      snowCanvas.width = canvas.width;
      snowCanvas.height = canvas.height;
      initSnow();
      updateSnow();
  } else {
      snowCanvas.classList.add('hidden');
  }
}

    
    function resetTrack(track){
      drawing = false;
      pointsPath = [];
      intersectedGates.clear();
      finalTimeOutput.textContent = `‚è∞1'00"000'''`;
      statusOutput.innerHTML = '';
      lastStatusMessage = '';
      resetBlindMode();
      clearCanvas();
      if(track) drawTrack(track);
    }
    
    function endRace(){
      const sorted = [...bestTimes].sort((a, b) => a.time - b.time);
      for(let i = 0; i < 5; i++){
        if(i < sorted.length){
          const entry = sorted[i];
          championScores[entry.name] += CHAMPION_POINTS[i];
          if(entry.blind){
            championScores[entry.name] += 3;
          }
        }
      }
      showRaceResults();
    }
    
    function showRaceResults(){
      let sortedTimes = [...bestTimes].sort((a, b) => a.time - b.time);
      let html = `
        <h2>Tempi finali (Top 5)</h2>
        <div class="champ-table">
          <table>
            <tr><th>Player</th><th>Tempo</th></tr>
      `;
      sortedTimes.forEach(e => {
        const blindMark = e.blind ? ' (B)' : '';
        html += `<tr><td>${e.name}</td><td>${formatTime(e.time)}${blindMark}</td></tr>`;
      });
      html += `</table></div>`;
      const sortedPlayers = Object.keys(championScores)
        .sort((a, b) => championScores[b] - championScores[a]);
      html += `
        <h2>Race Standings #${raceNumber}</h2>
        <div class="champ-table">
          <table>
            <tr><th>Player</th><th>Total Points</th></tr>
      `;
      sortedPlayers.forEach(name => {
        html += `<tr><td>${name}</td><td>${championScores[name]}</td></tr>`;
      });
      html += `</table></div>`;
      let btnLabel = "Next Race!";
      let action = () => {
        champOverlay.classList.add('hidden');
        raceNumber++;
        participants = sortedPlayers.slice().reverse();
        setupRace();
      };
      if(raceNumber >= 3){
        btnLabel = "Final Standings!";
        action = showFinalResults;
      }
      html += `<button class="nav-button">${btnLabel}</button>`;
      champContent.innerHTML = html;
      champContent.querySelector('.nav-button').addEventListener('click', action);
      champOverlay.classList.remove('hidden');
    }
    
    function showFinalResults(){
      let sortedPlayers = Object.keys(championScores)
        .sort((a, b) => championScores[b] - championScores[a]);
      const winner = sortedPlayers[0];
      let html = `
        <h2>Final Standings</h2>
        <div class="champ-table">
          <table>
            <tr><th>Player</th><th>Punti</th></tr>
      `;
      sortedPlayers.forEach(n => {
        html += `<tr><td>${n}</td><td>${championScores[n]}</td></tr>`;
      });
      html += `</table></div>`;
      html += `<h3>Wins ${winner}!!!</h3>`;
      html += `
        <div class="end-buttons">
          <button id="btnReplayChamp">Play Again!</button>
          <button id="btnSolo">Play Solo</button>
        </div>
      `;
      champContent.innerHTML = html;
      champContent.querySelector('#btnReplayChamp').addEventListener('click', () => {
        champOverlay.classList.add('hidden');
        slidesOverlay.classList.remove('hidden');
        currentSlideIndex = 0;
        renderSlide();
      });
      champContent.querySelector('#btnSolo').addEventListener('click', () => {
        window.location.href = 'index.html';
      });
      champOverlay.classList.remove('hidden');
    }
    
function setupRace(){
  // Azzeriamo la lastCompleteRun per dimenticare la run precedente
  lastCompleteRun = null;

  // Resetta il tempo mostrato
  finalTimeOutput.textContent = `‚è∞1'00"000'''`;

  // ==================================================
  // METEO: Rivalutazione all'inizio della gara
  // ==================================================
  let newWeatherState;
  if (!weatherState) {
    newWeatherState = chooseWeatherState(null);
  } else {
    newWeatherState = chooseWeatherState(weatherState);
  }
  showSnow = applyWeatherState(newWeatherState);

  const snowCanvas = document.getElementById('snowCanvas');
  if (showSnow) {
    snowCanvas.classList.remove('hidden');
    snowCanvas.width = canvas.width;
    snowCanvas.height = canvas.height;
    initSnow();
    updateSnow();
  } else {
    snowCanvas.classList.add('hidden');
  }

  currentTrack = createTrackForRace(raceNumber);
  resizeCanvas();
  drawTrack(currentTrack);
  bestTimes = [];
  updateLeaderboard();
  currentIndex = 0;
  attemptCount = 0;
  runNumber = 1;
  callParticipant();
}

    
    /* =======================================
       Popup generico
    ======================================= */
    function showPopup(message, onOk){
      champContent.innerHTML = `
        <h2>Attention</h2>
        <p class="slide-content">${message}</p>
        <button class="nav-button">OK</button>
      `;
      champOverlay.classList.remove('hidden');
      champContent.querySelector('.nav-button').addEventListener('click', () => {
        champOverlay.classList.add('hidden');
        if(onOk) onOk();
        restoreStatusOutput();
      });
    }
    
    /* =======================================
       SLIDES INTRO & GESTIONE PLAYER
    ======================================= */
    slidesIntro = [
      {
        title:"Ski-Zag Championship!‚õ∑Ô∏è",
        content: `
          Enter the players!<br>
          <div id="playersInputContainer"></div>
          <button id="addPlayerBtn" style="margin-right:8px;">Add Player</button>
          <button id="removePlayerBtn">Remove Player</button>
        `
      },
      {
        title:"Race Info üèÅ",
        content: `
          There will be 3 distinct races (Giant, Special, SuperG). Each race has 2 runs (manches), and in each run every participant has 3 consecutive attempts.
        `
      },
      {
        title:"Top 5 Scoring ‚è∞",
        content: `
          At the end of each race, the top 5 best times are awarded points (9, 7, 5, 3, 1).
        `
      },
      {
        title:"Final VictoryüèÜ",
        content: `
          At the end of the 3rd race, whoever has the most points wins the championship! Have fun!!
        `
      }
    ];
    let draftParticipants = [];
    function renderSlide(){
      slidesOverlay.classList.remove('hidden');
      const slide = slidesIntro[currentSlideIndex];
      slidesContent.innerHTML = `
        <h2 class="slide-title">${slide.title}</h2>
        <p class="slide-content">${slide.content}</p>
        <div class="tutorial-dots"></div>
        <div class="slides-nav">
          <button class="nav-button" id="btnPrev">‚Üê</button>
          <button class="nav-button" id="btnStartNow">Start!</button>
          <button class="nav-button" id="btnNext">‚Üí</button>
        </div>
      `;
      const dotsC = slidesContent.querySelector('.tutorial-dots');
      slidesIntro.forEach((s, i) => {
        const d = document.createElement('div');
        d.className = "dot" + (i === currentSlideIndex ? " active" : "");
        d.addEventListener('click', () => {
          syncDraftParticipants();
          currentSlideIndex = i;
          renderSlide();
        });
        dotsC.appendChild(d);
      });
      const btnPrev = slidesContent.querySelector('#btnPrev');
      btnPrev.disabled = (currentSlideIndex === 0);
      btnPrev.addEventListener('click', () => {
        if(currentSlideIndex > 0){
          syncDraftParticipants();
          currentSlideIndex--;
          renderSlide();
        }
      });
      slidesContent.querySelector('#btnStartNow').addEventListener('click', () => {
        syncDraftParticipants();
        if(!checkDraftNames()) return;
        acceptDraftParticipants();
        startChampionship();
      });
      const btnNext = slidesContent.querySelector('#btnNext');
      btnNext.disabled = (currentSlideIndex === slidesIntro.length - 1);
      btnNext.addEventListener('click', () => {
        if(currentSlideIndex < slidesIntro.length - 1){
          syncDraftParticipants();
          currentSlideIndex++;
          renderSlide();
        }
      });
      if(currentSlideIndex === 0){
        renderPlayersInput();
      }
    }
    
    function renderPlayersInput(){
      const cont = slidesContent.querySelector('#playersInputContainer');
      cont.innerHTML = '';
      if(draftParticipants.length < 2){
        draftParticipants = ['', ''];
      }
      draftParticipants.forEach(n => {
        addPlayerField(cont, n);
      });
      slidesContent.querySelector('#addPlayerBtn').addEventListener('click', () => {
        syncDraftParticipants();
        if(draftParticipants.length < 6){
          draftParticipants.push('');
          renderSlide();
        } else {
          alert("Max 6 participants!");
        }
      });
      slidesContent.querySelector('#removePlayerBtn').addEventListener('click', () => {
        syncDraftParticipants();
        if(draftParticipants.length > 2){
          draftParticipants.pop();
          renderSlide();
        }
      });
    }
    
    function addPlayerField(container, def = ''){
      const d = document.createElement('div');
      d.innerHTML = `
        <input type="text" class="player-name-input"
         placeholder="Player name"
         style="margin-bottom:5px;width:100%;padding:6px;border-radius:6px;border:1px solid #ccc;"
         value="${def}"
        />
      `;
      container.appendChild(d);
    }
    
    function syncDraftParticipants(){
      const inputs = slidesContent.querySelectorAll('.player-name-input');
      if(inputs.length === 0) return;
      draftParticipants = [];
      inputs.forEach(inp => {
        const val = inp.value.trim();
        if(val) draftParticipants.push(val);
      });
    }
    
    function checkDraftNames(){
      if(draftParticipants.length < 2){
        alert("At least 2 participants!");
        return false;
      }
      if(draftParticipants.length > 6){
        alert("Max 6 participants!");
        return false;
      }
      const duplicates = draftParticipants.some((nm, idx) =>
        draftParticipants.indexOf(nm) !== idx
      );
      if(duplicates){
        alert("Names must be unique!");
        return false;
      }
      return true;
    }
    
    function acceptDraftParticipants(){
      participants = [...draftParticipants];
    }
    
    function startChampionship(){
      championScores = {};
      participants.forEach(p => {
  championScores[p] = 0; // Reset dei punti del campionato
  treeHits[p] = 0;       // Reset delle penalit√† accumulate
});
      slidesOverlay.classList.add('hidden');
      raceNumber = 1;
      runNumber = 1;
      setupRace();
    }
    document.getElementById('quit').addEventListener('click', () => {
  const confirmQuit = confirm("Are you sure you want to quit?");
  if (confirmQuit) {
    window.location.href = 'index.html'; // Reindirizza alla pagina iniziale
  }
});

    document.addEventListener('DOMContentLoaded', () => {
      resizeCanvas();
      renderSlide();
      resetBlindMode();
    });
  </script>
</body>
</html>
