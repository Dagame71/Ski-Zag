<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <!-- Disabilita pinch-to-zoom / doppio tap -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <title>Ski Championship</title>
  <style>
    /* Stili di base */
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: "Helvetica Neue", Arial, sans-serif;
      background: #ffffff;
    }
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .container {
      position: relative;
      width: 90vw; /* 90% della larghezza della viewport */
      max-width: 600px; /* Limite massimo per schermi grandi */
      aspect-ratio: 300 / 520; /* Mantiene il rapporto di aspetto */
      background: #e1dffc url("sfondo.png") no-repeat center center;
      background-size: cover;
      border: 2px solid #ffffff;
      border-radius: 10px;
      margin-top: 20px;
      box-sizing: border-box;
      overflow: hidden;
    }
    canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      cursor: crosshair;
    }
    /* Canvas per l'effetto neve */
    #snowCanvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 10;
    }
    /* Bottoni */
    button {
      border: none;
      background: none;
      cursor: pointer;
      font-size: 1em; /* Dimensione relativa */
      margin: 0;
      padding: 0;
      color: black;
      z-index: 20;
    }
    button:hover { opacity: 0.7; }
    /* Posizionamento bottoni con percentuali */
    #sameTrack { 
      position: absolute; 
      bottom: 2%; 
      left: 3%; 
    }
    #replayButton { 
      position: absolute; 
      bottom: 2%; 
      left: 10%; 
    }
    #quit { 
      position: absolute; 
      top: 2%; 
      left: 3%; 
    }
    #chronoButton { 
      position: absolute; 
      top: 2%; 
      right: 3%; 
    }
    /* Bottone per Blind Mode */
    #blindToggle { 
      font-size: 1em; /* Dimensione relativa */
      padding: 0.5em 0.8em; /* Padding relativo */
      position: absolute;
      bottom: 1%; 
      left: 90%; /* Posizionato relativamente alla larghezza */
      transform: translateX(-50%);
      cursor: pointer;
    }
    /* Informazioni */
    .info-container {
      margin-top: 13px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    #finalTimeOutput { 
      margin: -10px 0; 
      font-weight: bold; 
      font-size: 1.2em; /* Dimensione relativa */
    }
    #statusOutput { 
      margin: 15px 0; 
      font-weight: bold; 
      color: red; 
      min-height: 20px; 
      font-size: 1em; /* Dimensione relativa */
    }
    /* Animazioni */
    @keyframes blink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0; }
    }
    .record { animation: blink 0.5s ease-in-out 3; }
    @keyframes fadeIn { 
      from { opacity: 0; } 
      to { opacity: 1; } 
    }
    /* Overlay */
    .overlay {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background-color: rgba(0, 0, 0, 0.7);
      z-index: 9999;
      display: flex; 
      justify-content: center; 
      align-items: center;
      animation: fadeIn 0.3s ease;
    }
    .hidden { display: none; }
    .overlay-content {
      background-image: url('backpopup.png');
      background-repeat: no-repeat;
      background-position: center;
      background-size: cover; /* Oppure "contain" se preferisci che l'intera immagine sia visibile */
      background-color: #fff; /* Colore di fallback se l'immagine non viene caricata */
      border-radius: 12px;
      padding: 2%; /* Padding relativo */
      width: 80%; /* Responsive width */
      max-width: 700px; /* Limite massimo */
      box-sizing: border-box;
      position: relative; 
      text-align: center; 
      color: #333;
      box-shadow: 
        inset 4px 4px 2px rgba(175,219,245,0.8),  /* Ombra interna scura in basso a destra */
        inset -4px -4px 2px rgba(255,255,255,0.8); /* Ombra interna chiara in alto a sinistra */
    }
    /* Correzione degli errori di sintassi */
    /* Rimosso '}' in eccesso */
    /* Bottoni per chiudere gli overlay */
    #closeOverlay { 
      position: absolute; 
      top: 10px; 
      left: 10px; 
      background-color: #dc3545; 
      font-size: 0.875em; /* Dimensione relativa */
      padding: 0.5em 1em; /* Padding relativo */
      color: white; 
      border: none; 
      border-radius: 5px; 
      cursor: pointer; 
    }
    #closeOverlay:hover { 
      background-color: #c82333; 
    }
    /* Leaderboard */
    .leaderboard-container { 
      display: block; 
      width: 100%; 
      margin-top: 10px; 
    }
    .leaderboard { 
      width: 80%; 
      margin: 0 auto; 
    }
    .leaderboard h2 { 
      text-align: center; 
      margin: 10px 0; 
      font-size: 1.2em; /* Dimensione relativa */
    }
    ol { 
      border: 1px solid #ccc; 
      border-radius: 5px; 
      list-style: decimal inside; 
      min-height: 100px; 
      padding: 10px; 
      margin: 0; 
    }
    li { 
      padding: 5px 0; 
      font-size: 1em; /* Dimensione relativa */
    }
    /* Slider del tutorial */
    .intro-overlay { }
    .slide-content { 
      margin-bottom: 20px; 
      line-height: 1.4; 
      font-size: 1em; /* Dimensione relativa */
    }
    .slide-title { 
      margin-top: 0; 
      margin-bottom: 10px; 
      font-size: 1.5em; /* Dimensione relativa */
    }
    .slides-nav { 
      display: flex; 
      justify-content: space-between; 
      align-items: center; 
      margin-top: 15px; 
    }
    .slides-nav .nav-button { 
      background: #007bff; 
      color: #fff; 
      border: none; 
      border-radius: 8px; 
      padding: 0.5em 1em; /* Padding relativo */
      font-size: 1em; /* Dimensione relativa */
      cursor: pointer; 
    }
    .slides-nav .nav-button:disabled { 
      background: #999; 
      cursor: not-allowed; 
    }
    .tutorial-dots { 
      display: flex; 
      justify-content: center; 
      gap: 8px; 
      margin: 10px 0; 
    }
    .dot { 
      width: 10px; 
      height: 10px; 
      border-radius: 50%; 
      background: #ccc; 
      cursor: pointer; 
      transition: background 0.3s; 
    }
    .dot.active { 
      background: #007bff; 
    }
    /* Tabella del campionato */
    .champ-table { 
      margin: 15px 0; 
      border: 1px solid #ccc; 
      border-radius: 8px; 
      width: 100%; 
      overflow: hidden; 
      text-align: left; 
    }
    .champ-table table { 
      width: 100%; 
      border-collapse: collapse; 
    }
    .champ-table th, .champ-table td { 
      padding: 8px; 
      border-bottom: 1px solid #eee; 
      font-size: 1em; /* Dimensione relativa */
    }
    .champ-table th { 
      background: #f7f7f7; 
      font-weight: bold; 
    }
    .champ-table tr:last-child td { 
      border-bottom: none; 
    }
    /* Bottoni alla fine */
    .end-buttons { 
      display: flex; 
      justify-content: center; 
      gap: 10px; 
      margin-top: 20px; 
    }
    .end-buttons button { 
      background: #007bff; 
      color: #fff; 
      border: none; 
      border-radius: 8px; 
      padding: 0.5em 1em; /* Padding relativo */
      font-size: 1em; /* Dimensione relativa */
      cursor: pointer; 
    }
    .end-buttons button:hover { 
      background-color: #0056b3; 
    }

    /* Media Queries per Schermi Pi√π Grandi */
    @media (min-width: 600px) {
      .container {
        max-width: 900px; /* Aumentato da 600px a 900px */
      }
      
      #replayButton { 
        left: 15%; /* Sposta leggermente a sinistra */
      }
      
      #blindToggle { 
        left: 88%; /* Adeguamento posizione */
      }
    }

    @media (min-width: 900px) {
      .container {
        max-width: 1200px; /* Aumentato da 900px a 1200px */
      }
      
      #replayButton { 
        left: 20%; /* Ulteriore spostamento */
      }
      
      #blindToggle { 
        left: 85%; /* Adeguamento posizione */
      }
    }

    @media (min-width: 1200px) {
      .container {
        max-width: 1500px; /* Aumentato da 1200px a 1500px */
      }
      
      #replayButton { 
        left: 25%; /* Ulteriore spostamento */
      }
      
      #blindToggle { 
        left: 82%; /* Adeguamento posizione */
      }
    }

  </style>
</head>
<body>
  <!-- Calibrazione -->
  <div id="calibrationTest" style="width:1in; position:absolute; left:-1000px; top:-1000px;"></div>
  
  <div class="container">
    <canvas id="canvas"></canvas>
    <!-- Canvas per l'effetto neve -->
    <canvas id="snowCanvas" class="hidden"></canvas>
    
    <!-- Bottoni di controllo -->
    <button id="sameTrack" title="Same Run" hidden>üîÅ</button>
    <button id="replayButton" title="Replay">
      <img src="replay.png" alt="Replay" style="width: 1.3em; height: 1.3em;">
    </button>
    <button id="chronoButton" title="Chrono">
      <img src="stopwatch.png" alt="Chrono" style="width:1.3em; height:1.3em;">
    </button>
    <button id="quit" title="Close">
      <img src="close.png" alt="Close" style="width:1.2em; height:1.2em;">
    </button>
    <!-- Bottone per Blind Mode -->
    <button id="blindToggle" title="Toggle Blind Mode">
      <img id="blindIcon" src="view.png" alt="View Mode" style="width:1.5em; height:1.5em;">
    </button>
    
    <!-- Overlay CHRONO (Top 5) -->
    <div id="chronoOverlay" class="overlay hidden">
      <div class="overlay-content">
        <button id="closeOverlay">X</button>
        <div class="leaderboard-container">
          <div class="leaderboard">
            <h2>Top 5</h2>
            <ol id="leaderboardList"></ol>
          </div>
        </div>
        <!-- Sezione Classifica Punti -->
        <div class="leaderboard-container">
          <div class="leaderboard">
            <h2>Classifica Punti</h2>
            <div class="champ-table">
              <table id="pointsLeaderboardTable">
                <thead>
                  <tr>
                    <th>Player</th>
                    <th>Punti</th>
                  </tr>
                </thead>
                <tbody id="pointsLeaderboardBody">
                  <!-- Dati inseriti dinamicamente -->
                </tbody>
              </table>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
  
  <div class="info-container">
    <p id="finalTimeOutput">‚è∞1'00"000'''</p>
    <p id="statusOutput"></p>
  </div>
  
  <!-- OVERLAY INTRO E SLIDES -->
  <div id="slidesOverlay" class="overlay hidden">
    <div id="slidesContent" class="overlay-content intro-overlay"></div>
  </div>
  
  <!-- OVERLAY ANNUNCI E CLASSIFICHE -->
  <div id="champOverlay" class="overlay hidden">
    <div id="champContent" class="overlay-content"></div>
  </div>
  
  <script>
    /* ==============================================
       VARIABILI GLOBALI
    ============================================== */
    const PATH_LENGTH_SCALING = 500;
    const PENALTY_WEIGHT      = 0.5;
    const BORDER_THRESHOLD = 5; // Considera "al bordo" se la traiettoria sta entro 5px dal limite del canvas.
    
    const canvas           = document.getElementById('canvas');
    const ctx              = canvas.getContext('2d');
    const finalTimeOutput  = document.getElementById('finalTimeOutput');
    const statusOutput     = document.getElementById('statusOutput');
    const sameTrackButton  = document.getElementById('sameTrack');
    const replayButton     = document.getElementById('replayButton');
    const chronoButton     = document.getElementById('chronoButton');
    const chronoOverlay    = document.getElementById('chronoOverlay');
    const closeOverlay     = document.getElementById('closeOverlay');
    const slidesOverlay    = document.getElementById('slidesOverlay');
    const slidesContent    = document.getElementById('slidesContent');
    const champOverlay     = document.getElementById('champOverlay');
    const champContent     = document.getElementById('champContent');
    
    // Variabili di gioco e stato
    let bestTimes        = [];
    let currentTrack     = null;
    let gates            = [];
    let trees            = [];
    let pointsPath       = [];
    let drawing          = false;
    let startTime        = 0;
    let intersectedGates = new Set();
    let participants     = [];
    let championScores   = {};
    let currentIndex     = 0;
    let attemptCount     = 0;
    let raceNumber       = 1;
    let runNumber        = 1;
    const CHAMPION_POINTS= [9,7,5,3,1];
    let hardMode         = true;
    let slidesIntro      = [];
    let currentSlideIndex= 0;
    let didFinishOrFailThisRun = false;
    let lastStatusMessage = '';
    let lastCompleteRun   = null;
    let falseStartCount   = 0;
    let weatherState      = null;  // "nn", "pn", "mn", "nf"
    let snowIntensity     = 0;     // Intensit√† neve
    let showSnow          = false; // Flag effetto neve
    let globalWind = Math.random() * 1 - 0.5;
    let replaySnowState = false; // Per memorizzare lo stato della neve
    // Nuova variabile per gestire i colpi con l'albero
    let treeHits = {}; // Es.: treeHits["Mario"] = numero di impatti consecutivi
    
    // Impostazioni canvas e coordinate di partenza/arrivo
    let startPoint = { x:150, y:30 };
    let finishRect = { x:130, y:490, width:40, height:10 };
    let lastSnowActive = false;
    let outPenaltyCount = 0; // Conta quante volte la traiettoria esce dal campo
    let isOut = false;       // Flag per rilevare quando si esce ed evitare conteggi multipli continui
    
    /* =======================================
       Funzione di interpolazione: controlla se tra p1 e p2 viene "toccatto" il bordo
    ======================================= */
    function checkInterpolationForBorder(p1, p2) {
      const stepLength = 2;  // Lunghezza del passo in pixel
      const dx = p2.x - p1.x;
      const dy = p2.y - p1.y;
      const distance = Math.hypot(dx, dy);
      const steps = Math.ceil(distance / stepLength);
      
      // Interpola tra p1 e p2
      for (let i = 1; i <= steps; i++) {
        const t = i / steps;
        const ix = p1.x + t * dx;
        const iy = p1.y + t * dy;
        if (ix < BORDER_THRESHOLD || ix > canvas.width - BORDER_THRESHOLD ||
            iy < BORDER_THRESHOLD || iy > canvas.height - BORDER_THRESHOLD) {
          return true;
        }
      }
      return false;
    }
    
    /* =======================================
       Resize Canvas Responsivo
    ======================================= */
    function resizeCanvas(){
      // Imposta le dimensioni del canvas in base alla dimensione del contenitore
      const container = document.querySelector('.container');
      canvas.width = container.clientWidth;
      canvas.height = container.clientHeight;
      startPoint = { x: canvas.width / 2, y: 30 };
      finishRect = { x: (canvas.width / 2) - 20, y: canvas.height - 30, width:40, height:10 };
      
      // Aggiorna anche il canvas neve
      const snowCanvas = document.getElementById('snowCanvas');
      snowCanvas.width = canvas.width;
      snowCanvas.height = canvas.height;
    }
    
    /* =======================================
       Clear Canvas
    ======================================= */
    function clearCanvas(){
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    }
    
    /* =======================================
       Calibrazione
    ======================================= */
    window.addEventListener('load', () => {
      const cal = document.getElementById('calibrationTest');
      window.conversionFactor = cal.offsetWidth / 96;
    });
    
    /* =======================================
       Impostazione delle icone e risorse
    ======================================= */
    const gateIcons = {
      red: new Image(),
      blue: new Image()
    };
    gateIcons.red.src = "red_gate.svg";
    gateIcons.blue.src = "blue_gate.svg";
    
    /* =======================================
       Funzioni Meteo (unificate)
    ======================================= */
    function chooseWeatherState(prevState) {
      const r = Math.random() * 100;
      switch (prevState) {
        case "nn":
          if (r < 50) return "nn";
          else if (r < 80) return "pn";
          else if (r < 95) return "mn";
          else return "nf";
        case "pn":
          if (r < 25) return "nn";
          else if (r < 65) return "pn";
          else if (r < 90) return "mn";
          else return "nf";
        case "mn":
          if (r < 20) return "nn";
          else if (r < 50) return "pn";
          else if (r < 80) return "mn";
          else return "nf";
        case "nf":
          if (r < 20) return "nn";
          else if (r < 60) return "pn";
          else if (r < 80) return "mn";
          else return "nf";
        default:
          return "nn";
      }
    }
    
    function applyWeatherState(state) {
      if (state === "nn") {
        snowIntensity = 0;
      } else if (state === "pn") {
        snowIntensity = 300;
      } else if (state === "mn") {
        snowIntensity = 1000;
      } else if (state === "nf") {
        snowIntensity = 3250;
      }
      weatherState = state;
      return snowIntensity > 0;
    }
    
    /* =======================================
       Sistema neve: inizializza e aggiorna le particelle
    ======================================= */
    let snowCanvas = document.getElementById('snowCanvas');
    const snowCtx = snowCanvas.getContext('2d');
    let snowflakes = [];
    
    function initSnow(){
      snowflakes = [];
      for (let i = 0; i < snowIntensity; i++){
        snowflakes.push({
          x: Math.random() * snowCanvas.width,
          y: Math.random() * snowCanvas.height,
          radius: Math.random() * 3 + 1,
          speedY: Math.random() * 0.5 + 0.5,
          speedX: (Math.random() * 0.5) - 0.25
        });
      }
    }
    
    function updateSnow(){
      if (!showSnow) return;
      snowCtx.clearRect(0, 0, snowCanvas.width, snowCanvas.height);
      snowflakes.forEach(flake => {
        flake.x += flake.speedX + globalWind;
        flake.y += flake.speedY;
        if (flake.y > snowCanvas.height) {
          flake.y = 0;
          flake.x = Math.random() * snowCanvas.width;
        }
        if (flake.x > snowCanvas.width) flake.x = 0;
        if (flake.x < 0) flake.x = snowCanvas.width;
        snowCtx.beginPath();
        snowCtx.arc(flake.x, flake.y, flake.radius, 0, Math.PI * 2);
        snowCtx.fillStyle = 'white';
        snowCtx.fill();
      });
      requestAnimationFrame(updateSnow);
    }
    
    /* =======================================
       Generazione della Pista
    ======================================= */
    function createTrackForRace(rn){
      let gc = 8;
      if(rn === 2) gc = 10;
      if(rn === 3) gc = 6;
      const g = generateGates(gc);
      const t = generateTrees(g);
      return { gates: g, trees: t };
    }
    
    function generateGates(count){
      const startWithRed = (Math.random() < 0.5);
      let isRed = startWithRed;
      let arr = [];
      for(let i = 0; i < count; i++){
        const dir = isRed ? 1 : -1;
        const x   = isRed 
          ? Math.random() * (canvas.width / 2 - 35) + canvas.width / 2
          : Math.random() * (canvas.width / 2 - 35) + 35;
        const y   = 60 + i * ((canvas.height - 120) / count);
        const color = isRed ? 'red' : 'blue';
        arr.push({
          x, y, color,
          line: { x1: x, y1: y, x2: x + dir * 200, y2: y }
        });
        isRed = !isRed;
      }
      return arr;
    }
    
    function generateTrees(gArr){
      const treeCount = Math.floor(Math.random() * 3) + 6;
      let arr = [];
      const margin = 15;
      const minGate = 50, minTree = 30, minFinish = 50, minStart = 20, minTop = 30;
      while(arr.length < treeCount){
        const tx = margin + Math.random() * (canvas.width - 2 * margin);
        const ty = minTop + Math.random() * (canvas.height - minTop - margin);
        const closeGate = gArr.some(g => Math.hypot(tx - g.x, ty - g.y) < minGate);
        const closeTrees = arr.some(t => Math.hypot(tx - t.x, ty - t.y) < minTree);
        const closeFinish = isNearFinish(tx, ty, finishRect, minFinish);
        const closeStart = Math.hypot(tx - startPoint.x, ty - startPoint.y) < minStart;
        if(!closeGate && !closeTrees && !closeFinish && !closeStart){
          arr.push({ x: tx, y: ty });
        }
      }
      return arr;
    }
    
    /* =======================================
       Disegno della Pista e degli Elementi
    ======================================= */
    function drawTrack(track){
      clearCanvas();
      gates = track.gates;
      trees = track.trees;
      intersectedGates = new Set();
      drawStartPoint();
      drawFinishArea();
      drawGates(gates);
      drawTrees(trees);
    }
    
    function drawStartPoint(){
      ctx.font = `${18 / 520 * canvas.height}px Arial`; // Font relativo
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('üè†', startPoint.x, startPoint.y);
    }
    
    function drawFinishArea(){
      const { x, y, width, height } = finishRect;
      const sq = width / 8;
      const rowCount = Math.floor(height / (width / 8));
      for(let row = 0; row < rowCount; row++){
        for(let col = 0; col < 8; col++){
          ctx.fillStyle = ((row + col) % 2 === 0) ? 'black' : '#F0F0F0';
          ctx.fillRect(x + col * sq, y + row * sq, sq, sq);
        }
      }
    }
    
    function drawGates(gArr){
      gArr.forEach(g => {
        const icon = g.color === "red" ? gateIcons.red : gateIcons.blue;
        const iconWidth = 16 / 300 * canvas.width; // Dimensione relativa
        const iconHeight = 16 / 520 * canvas.height;
        ctx.drawImage(icon, g.x - iconWidth / 2, g.y - iconHeight / 2, iconWidth, iconHeight);
      });
    }
    
    function drawTrees(tArr){
      const treeImg = new Image();
      treeImg.src = './tree.svg';
      treeImg.onload = () => {
        tArr.forEach(t => {
          // Disegno con offset: l'immagine viene disegnata a t.x-6, t.y-20, dimensione 12x20
          const treeWidth = 12 / 300 * canvas.width;
          const treeHeight = 20 / 520 * canvas.height;
          ctx.drawImage(treeImg, t.x - treeWidth / 2, t.y - treeHeight, treeWidth, treeHeight);
        });
      };
    }
    
    /* =======================================
       Eventi Mouse / Touch (unificati)
    ======================================= */
    if(!canvas._eventsAttached){
      canvas.addEventListener('mousedown', handleMouseDown);
      canvas.addEventListener('mousemove', handleMouseMove);
      canvas.addEventListener('mouseup', handleMouseUp);
      canvas.addEventListener('touchstart', handleTouchStart);
      canvas.addEventListener('touchmove', handleTouchMove);
      canvas.addEventListener('touchend', handleTouchEnd);
      canvas._eventsAttached = true;
    }
    
    function getMouseCoords(e){
      const rect = canvas.getBoundingClientRect();
      const cx = (e.touches) ? e.touches[0].clientX : e.clientX;
      const cy = (e.touches) ? e.touches[0].clientY : e.clientY;
      return { x: (cx - rect.left) / rect.width * canvas.width, y: (cy - rect.top) / rect.height * canvas.height };
    }
    
    function isNearStartPoint(x,y){
      return (Math.hypot(x - startPoint.x, y - startPoint.y) <= 20 / 520 * canvas.height);
    }
    
    function handleMouseDown(e){
      const { x, y } = getMouseCoords(e);
      if(!isNearStartPoint(x, y)){
        falseStartCount++;  // Incrementa il contatore degli errori
    
        if(falseStartCount === 1) {
          statusOutput.innerHTML = '<span style="color:red;">False start!</span> <span style="color:black;">2nd attempt!</span>';
          setTimeout(() => {
            restoreStatusOutput();
          }, 1000); // Il messaggio resta per 1 secondo
        } else if(falseStartCount === 2) {
          statusOutput.innerHTML = '<span style="color:red;">False start!</span> <span style="color:black;">Last attempt!</span>';
          setTimeout(() => {
            restoreStatusOutput();
          }, 1000);
        } else if(falseStartCount >= 3){
          statusOutput.textContent = 'Run failed due to consecutive false starts!';
          failAttempt("Run failed due to false starts.");
          falseStartCount = 0;  // Reset dopo il fallimento
        }
        return;
      }
      // Se il punto di partenza √® corretto, resettiamo il conteggio
      falseStartCount = 0;
    
      // Resettiamo le variabili per la penalit√† "uscita dal campo"
      outPenaltyCount = 0;
      isOut = false;
    
      drawing = true;
      pointsPath = [];
      startTime = performance.now();
      statusOutput.textContent = '';
      lastStatusMessage = '';
      ctx.beginPath();
      pointsPath.push({ x, y, t: 0 });
      ctx.moveTo(x, y);
      didFinishOrFailThisRun = false;
    }
    
    
    function handleMouseMove(e){
      if(!drawing) return;
      const { x, y } = getMouseCoords(e);
      
      // Preleva l'ultimo punto registrato (se esiste)
      let p1 = pointsPath[pointsPath.length - 1];
      let p2 = { x, y };
    
      // Usa l'interpolazione per verificare se il segmento attraversa il bordo
      if (p1 && checkInterpolationForBorder(p1, p2)) {
        if(!isOut) {  // Se non √® gi√† stato segnato come "al bordo"
          outPenaltyCount++; // Incrementa la penalit√†
          isOut = true;
        }
      } else {
        isOut = false;
      }
    
      // Registra il nuovo punto con il tempo relativo
      const now = performance.now() - startTime;
      pointsPath.push({ x, y, t: now });
      
      if(!isBlind){
        ctx.lineTo(x, y);
        ctx.strokeStyle = '#a4b8eb';
        ctx.lineWidth = 2 / 520 * canvas.height; // Line width relativo
        ctx.stroke();
      }
      checkIntersections();
    }
        
    function handleMouseUp(e){
      if(!drawing) return;
      drawing = false;
      if(!didFinishOrFailThisRun){
        failAttempt("Run interrupted!");
      }
    }
    
    function handleTouchStart(e){
      e.preventDefault();
      const { x, y } = getMouseCoords(e);
      if(!isNearStartPoint(x,y)){
        statusOutput.textContent = 'You must start from the start point!';
        return;
      }
      
      // Reset delle variabili per la penalit√† "uscita dal campo"
      outPenaltyCount = 0;
      isOut = false;
      
      drawing = true;
      pointsPath = [];
      startTime = performance.now();
      statusOutput.textContent = '';
      lastStatusMessage = '';
      ctx.beginPath();
      pointsPath.push({ x, y, t: 0 });
      ctx.moveTo(x, y);
      didFinishOrFailThisRun = false;
    }
    
        
    function handleTouchMove(e){
      e.preventDefault();
      if(!drawing) return;
      const { x, y } = getMouseCoords(e);
    
      let p1 = pointsPath[pointsPath.length - 1];
      let p2 = { x, y };
    
      // Utilizza la funzione di interpolazione per controllare il contatto con il bordo
      if (p1 && checkInterpolationForBorder(p1, p2)) {
        if(!isOut) {
          outPenaltyCount++;
          isOut = true;
        }
      } else {
        isOut = false;
      }
      
      const now = performance.now() - startTime;
      pointsPath.push({ x, y, t: now });
      
      if(!isBlind){
        ctx.lineTo(x, y);
        ctx.strokeStyle = '#a4b8eb';
        ctx.lineWidth = 2 / 520 * canvas.height; // Line width relativo
        ctx.stroke();
      }
      checkIntersections();
    }
    
        
    function handleTouchEnd(e){
      e.preventDefault();
      if(!drawing) return;
      drawing = false;
      if(!didFinishOrFailThisRun){
        failAttempt("Run interrupted!");
      }
    }
    
    function checkIntersections(){
      for(let i = 1; i < pointsPath.length; i++){
        const p1 = pointsPath[i-1], p2 = pointsPath[i];
        if(hardMode){
          for(const tree of trees){
            const steps = Math.ceil(Math.hypot(p2.x-p1.x, p2.y-p1.y) / 5);
            for(let j = 0; j <= steps; j++){
              const ix = p1.x + (p2.x-p1.x) * (j/steps);
              const iy = p1.y + (p2.y-p1.y) * (j/steps);
              // Per l'immagine dell'albero, il disegno usa un offset: l'icona √® disegnata in (tree.x-6, tree.y-20)
              // Il centro visivo √® dunque (tree.x, tree.y-10)
              const dist = Math.hypot(ix - tree.x, iy - (tree.y - 10));
              if(dist < 10 / 520 * canvas.height){
                // Registra il colpo dell'albero per il giocatore attuale
                let currentPlayer = participants[currentIndex];
                if (!treeHits[currentPlayer]) {
                  treeHits[currentPlayer] = 1;
                } else {
                  treeHits[currentPlayer]++;
                }
                failAttempt("You hit a tree!");
                return;
              }
            }
          }
        }
        for(const [idx, gate] of gates.entries()){
          if(linesIntersect(p1.x, p1.y, p2.x, p2.y, gate.line.x1, gate.line.y1, gate.line.x2, gate.line.y2)){
            intersectedGates.add(idx);
          }
        }
        if(isSegmentInFinishArea(p1, p2, finishRect)){
          if(intersectedGates.size === gates.length){
            finishRun();
          } else {
            failAttempt("You missed a gate!");
          }
          return;
        }
      }
    }
    
    function linesIntersect(x1, y1, x2, y2, x3, y3, x4, y4){
      const det = (x2 - x1) * (y4 - y3) - (y2 - y1) * (x4 - x3);
      if(det === 0) return false;
      const lambda = ((y4 - y3) * (x4 - x1) + (x3 - x4) * (y4 - y1)) / det;
      const gamma  = ((y1 - y2) * (x4 - x1) + (x2 - x1) * (y4 - y1)) / det;
      return (lambda >= 0 && lambda <= 1 && gamma >= 0 && gamma <= 1);
    }
    
    function isSegmentInFinishArea(p1, p2, rect){
      if((p1.y < rect.y && p2.y < rect.y) || (p1.y > rect.y + rect.height && p2.y > rect.y + rect.height))
        return false;
      if((p1.x < rect.x && p2.x < rect.x) || (p1.x > rect.x + rect.width && p2.x > rect.x + rect.width))
        return false;
      return true;
    }
    
    function isNearFinish(x, y, rect, minD){
      return (
        x >= rect.x - minD &&
        x <= rect.x + rect.width + minD &&
        y >= rect.y - minD &&
        y <= rect.y + rect.height + minD
      );
    }
    
    /* =======================================
       Gestione dei Tentativi
    ======================================= */
    function failAttempt(msg) {
      drawing = false;
      didFinishOrFailThisRun = true;
    
      // Salva il percorso della run non conclusa
      if (pointsPath.length > 0) {
        lastCompleteRun = JSON.parse(JSON.stringify(pointsPath)); // Salva il percorso corrente
      }
    
      // Se stiamo giocando in modalit√† blind, assegniamo +3 punti agli altri giocatori
      if (isBlind) {
        statusOutput.textContent = "Blind failed! Penalty!";
        for (let player in championScores) {
          if (player !== participants[currentIndex]) {
            championScores[player] += 3;
          }
        }
        updatePointsLeaderboard();
      } else {
        statusOutput.textContent = msg;
      }
    
      lastStatusMessage = statusOutput.textContent;
      attemptCount++;
      setTimeout(() => nextParticipant(), 2000);
    }
    
    function finishRun(){
      drawing = false;
      didFinishOrFailThisRun = true;
      const endTime = performance.now();
      const elapsedTime = endTime - startTime;
      const distPx = calculateDistance(pointsPath);
      const realLength = distPx * (window.conversionFactor || 1);
      
      // Calcola il tempo base
      let baseTime = calculateFinalTime(elapsedTime, realLength);
      
      // Penalit√† per alberi (gi√† esistente)
      let currentPlayer = participants[currentIndex];
      let extraPenalty = 0;
      if (treeHits[currentPlayer]) {
        extraPenalty = 0.02 * Math.pow(2, treeHits[currentPlayer] - 1);
      }
      
      // Nuova penalit√†: per ogni uscita dal campo, +0.10 secondi
      let outPenaltyTotal = outPenaltyCount * 0.10;
      
      // Calcola il tempo finale sommando le penalit√†
      const finalTime = baseTime + extraPenalty + outPenaltyTotal;
      
      // Visualizza il tempo finale e mostra la penalit√† tra parentesi (se presente)
      finalTimeOutput.textContent = `‚è∞ ${formatTime(finalTime)}${(outPenaltyTotal > 0) ? `(+${outPenaltyTotal.toFixed(2)})` : ""}`;
      statusOutput.textContent = 'Finished!';
      lastStatusMessage = 'Finished!';
      
      // Salva il percorso per il replay
      lastCompleteRun = JSON.parse(JSON.stringify(pointsPath));
      
      // Salva lo stato della neve
      lastSnowActive = showSnow;
      
      updateTimes(finalTime);
      attemptCount++;
      resetBlindMode();
      setTimeout(() => nextParticipant(), 2500);
    }
    
    
    function calculateDistance(arr){
      let tot = 0;
      for(let i = 1; i < arr.length; i++){
        let dx = arr[i].x - arr[i-1].x;
        let dy = arr[i].y - arr[i-1].y;
        tot += Math.hypot(dx, dy);
      }
      return tot;
    }
    
    function calculateFinalTime(ms, dist){
      const s = ms / 1000;
      const penalty = PENALTY_WEIGHT * (dist / PATH_LENGTH_SCALING);
      return 60 + s + penalty;
    }
    
    function formatTime(sec){
      const m = Math.floor(sec / 60);
      const r = (sec % 60).toFixed(3);
      return `${m}'${r.replace('.', '"')}'''`;
    }
    
    /* =======================================
       Aggiornamento Leaderboard e Punteggi
    ======================================= */
    function updateTimes(t){
      const nameValue = participants[currentIndex];
      const replayData = JSON.parse(JSON.stringify(pointsPath));
      const newResult = {
        name: nameValue,
        time: t,
        replay: replayData,
        blind: isBlind
      };
      bestTimes.push(newResult);
      bestTimes.sort((a, b) => a.time - b.time);
      if(bestTimes.length > 5) bestTimes.length = 5;
      if(bestTimes[0].time === t){
        finalTimeOutput.classList.add('record');
        setTimeout(() => finalTimeOutput.classList.remove('record'), 2000);
      }
      updateLeaderboard();
    }
    
    chronoButton.addEventListener('click', () => {
      updateLeaderboard();
      updatePointsLeaderboard();
      chronoOverlay.classList.remove('hidden');
    });
    
    closeOverlay.addEventListener('click', () => {
      chronoOverlay.classList.add('hidden');
    });
    
    function updateLeaderboard(){
      const lb = document.getElementById('leaderboardList');
      lb.innerHTML = '';
      bestTimes.forEach((entry, i) => {
        const li = document.createElement('li');
        const blindMark = entry.blind ? ' (B)' : '';
        if(i === 0){
          li.innerHTML = `${entry.name} - ${formatTime(entry.time)}${blindMark} <span style="font-size:1.2em;">‚èØÔ∏è</span>`;
          li.style.fontWeight = 'bold';
          li.style.cursor = 'pointer';
          li.title = "Click to watch the best replay";
          li.addEventListener('click', () => {
            chronoOverlay.classList.add('hidden');
            replayTrajectory(entry.replay);
          });
        } else {
          li.textContent = `${entry.name} - ${formatTime(entry.time)}${blindMark}`;
        }
        lb.appendChild(li);
      });
    }
    
    function updatePointsLeaderboard(){
      const tableBody = document.getElementById('pointsLeaderboardBody');
      tableBody.innerHTML = '';
      const sortedPlayers = Object.keys(championScores).sort((a, b) => championScores[b] - championScores[a]);
      sortedPlayers.forEach(player => {
        const row = document.createElement('tr');
        const nameCell = document.createElement('td');
        const pointsCell = document.createElement('td');
        nameCell.textContent = player;
        pointsCell.textContent = championScores[player];
        row.appendChild(nameCell);
        row.appendChild(pointsCell);
        tableBody.appendChild(row);
      });
    }
    
    /* =======================================
       REPLAY della Traiettoria
    ======================================= */
    replayButton.addEventListener('click', () => {
      if (lastCompleteRun && lastCompleteRun.length >= 2) {
        replayTrajectory(lastCompleteRun);
      } else {
        statusOutput.textContent = "No run to replay!";
        setTimeout(() => {
          restoreStatusOutput();
        }, 2000); // 2000 millisecondi = 2 secondi
      }
    });
        
    function replayTrajectory(customPoints) {
      const rp = (customPoints && customPoints.length >= 2)
        ? customPoints : pointsPath;
      if (!rp || rp.length < 2) {
        statusOutput.textContent = "No run to replay!";
        lastStatusMessage = "No run to replay!";
        
        // Ripristina il messaggio di stato dopo 2 secondi
        setTimeout(() => {
          restoreStatusOutput();
        }, 1000);
        
        return;
      }
    
      // Salva lo stato della neve prima del replay
      const preReplaySnowState = showSnow;
    
      // Riattiva la neve se era attiva durante la corsa
      if (lastSnowActive) {
        showSnow = true;
        snowCanvas.classList.remove('hidden');
        snowCanvas.width = canvas.width;
        snowCanvas.height = canvas.height;
        initSnow();
        updateSnow();
      } else {
        snowCanvas.classList.add('hidden');
      }
    
      lastStatusMessage = statusOutput.innerHTML;
      clearCanvas();
      drawStartPoint();
      drawFinishArea();
      drawGates(gates);
      drawTrees(trees);
      let i = 0;
    
      function step() {
        if (i >= rp.length - 1) {
          setTimeout(() => {
            clearCanvas();
            if (currentTrack) drawTrack(currentTrack);
    
            // Ripristina lo stato della neve originale
            if (preReplaySnowState) {
              showSnow = true;
              snowCanvas.classList.remove('hidden');
              snowCanvas.width = canvas.width;
              snowCanvas.height = canvas.height;
              initSnow();
              updateSnow();
            } else {
              showSnow = false;
              snowCanvas.classList.add('hidden');
            }
    
            restoreStatusOutput();
          }, 500);
          return;
        }
    
        ctx.beginPath();
        ctx.moveTo(rp[i].x, rp[i].y);
        ctx.lineTo(rp[i + 1].x, rp[i + 1].y);
        ctx.strokeStyle = '#a4b8eb';
        ctx.lineWidth = 2 / 520 * canvas.height; // Line width relativo
        ctx.stroke();
        const dt = rp[i + 1].t - rp[i].t;
        i++;
        setTimeout(step, dt);
      }
      
      setTimeout(step, 0);
    }
    
    
    function restoreStatusOutput(){
      if(!champOverlay.classList.contains('hidden')){
          return;
      }
      // Se lastStatusMessage √® "No run to replay!", ripristina lo stato di gioco
      if (lastStatusMessage === "No run to replay!") {
          statusOutput.innerHTML = `Play ${participants[currentIndex]} (G${raceNumber}/M${runNumber}/R${attemptCount + 1})`;
      } else {
          statusOutput.innerHTML = lastStatusMessage || '';
      }
    }
    
    /* =======================================
       Blind Mode
    ======================================= */
    const blindToggleButton = document.getElementById('blindToggle');
    let isBlind = false;
    blindToggleButton.addEventListener('click', () => {
      isBlind = !isBlind;
      const blindIcon = document.getElementById('blindIcon');
      if (isBlind) {
        blindIcon.src = 'hide.png'; // occhio chiuso
        blindIcon.alt = 'Hide Mode';
      } else {
        blindIcon.src = 'view.png'; // occhio aperto
        blindIcon.alt = 'View Mode';
      }
    });
    
    function resetBlindMode(){
      isBlind = false;
      const blindIcon = document.getElementById('blindIcon');
      blindIcon.src = 'view.png';
      blindIcon.alt = 'View Mode';
    }
    
    /* =======================================
       Gestione Discesa, Manche e Gara
    ======================================= */
    function nextParticipant(){
      resetBlindMode();
      if(attemptCount >= 3){
        attemptCount = 0;
        currentIndex++;
        if(currentIndex >= participants.length){
          if(runNumber === 1){
            runNumber = 2;
            currentIndex = 0;
            showPopup(`Starting the 2nd manche of race #${raceNumber}!`, () => {
              resetTrack(currentTrack);
              callParticipant();
            });
          } else {
            endRace();
          }
        } else {
          const nxt = participants[currentIndex];
          showPopup(`Now it's ${nxt}'s turn!`, () => {
            resetTrack(currentTrack);
            callParticipant();
          });
        }
      } else {
        resetTrack(currentTrack);
        callParticipant();
      }
    }
    
    function callParticipant(){
      let att = attemptCount + 1;
      let currentPlayer = participants[currentIndex];
      let penaltyDisplay = "";
      if (treeHits[currentPlayer]) {
        // Calcola il penalty in secondi:
        let penaltyVal = 0.02 * Math.pow(2, treeHits[currentPlayer] - 1); 
        // Formatta il valore con 2 decimali, es. "0.02s"
        penaltyDisplay = `/+${penaltyVal.toFixed(2)}s`;
      }
      let msg = `<span style="color:black;">${currentPlayer}</span> (
        #<span style="color:black;">${raceNumber}</span>/
        M<span style="color:black;">${runNumber}</span>/
        Run<span style="color:black;">${att}</span>${penaltyDisplay}
      )`;
      statusOutput.innerHTML = msg;
      lastStatusMessage = msg;
      
      // Rivaluta il meteo all'inizio di ogni discesa
      let newWeatherState = chooseWeatherState(weatherState);
      showSnow = applyWeatherState(newWeatherState);
      
      const snowCanvas = document.getElementById('snowCanvas');
      if (showSnow) {
          snowCanvas.classList.remove('hidden');
          snowCanvas.width = canvas.width;
          snowCanvas.height = canvas.height;
          initSnow();
          updateSnow();
      } else {
          snowCanvas.classList.add('hidden');
      }
    }
    
    function resetTrack(track){
      drawing = false;
      pointsPath = [];
      intersectedGates.clear();
      finalTimeOutput.textContent = `‚è∞1'00"000'''`;
      statusOutput.innerHTML = '';
      lastStatusMessage = '';
      resetBlindMode();
      clearCanvas();
      if(track) drawTrack(track);
    }
    
    function endRace(){
      const sorted = [...bestTimes].sort((a, b) => a.time - b.time);
      for(let i = 0; i < 5; i++){
        if(i < sorted.length){
          const entry = sorted[i];
          championScores[entry.name] += CHAMPION_POINTS[i];
          if(entry.blind){
            championScores[entry.name] += 3;
          }
        }
      }
      showRaceResults();
    }
    
    function showRaceResults(){
      let sortedTimes = [...bestTimes].sort((a, b) => a.time - b.time);
      let html = `
        <h2>Tempi finali (Top 5)</h2>
        <div class="champ-table">
          <table>
            <tr><th>Player</th><th>Tempo</th></tr>
      `;
      sortedTimes.forEach(e => {
        const blindMark = e.blind ? ' (B)' : '';
        html += `<tr><td>${e.name}</td><td>${formatTime(e.time)}${blindMark}</td></tr>`;
      });
      html += `</table></div>`;
      const sortedPlayers = Object.keys(championScores)
        .sort((a, b) => championScores[b] - championScores[a]);
      html += `
        <h2>Race Standings #${raceNumber}</h2>
        <div class="champ-table">
          <table>
            <tr><th>Player</th><th>Total Points</th></tr>
      `;
      sortedPlayers.forEach(name => {
        html += `<tr><td>${name}</td><td>${championScores[name]}</td></tr>`;
      });
      html += `</table></div>`;
      let btnLabel = "Next Race!";
      let action = () => {
        champOverlay.classList.add('hidden');
        raceNumber++;
        participants = sortedPlayers.slice().reverse();
        setupRace();
      };
      if(raceNumber >= 3){
        btnLabel = "Final Standings!";
        action = showFinalResults;
      }
      html += `<button class="nav-button">${btnLabel}</button>`;
      champContent.innerHTML = html;
      champContent.querySelector('.nav-button').addEventListener('click', action);
      champOverlay.classList.remove('hidden');
    }
    
    function showFinalResults(){
      let sortedPlayers = Object.keys(championScores)
        .sort((a, b) => championScores[b] - championScores[a]);
      const winner = sortedPlayers[0];
      let html = `
        <h2>Final Standings</h2>
        <div class="champ-table">
          <table>
            <tr><th>Player</th><th>Punti</th></tr>
      `;
      sortedPlayers.forEach(n => {
        html += `<tr><td>${n}</td><td>${championScores[n]}</td></tr>`;
      });
      html += `</table></div>`;
      html += `<h3>Wins ${winner}!!!</h3>`;
      html += `
        <div class="end-buttons">
          <button id="btnReplayChamp">Play Again!</button>
          <button id="btnSolo">Play Solo</button>
        </div>
      `;
      champContent.innerHTML = html;
      champContent.querySelector('#btnReplayChamp').addEventListener('click', () => {
        champOverlay.classList.add('hidden');
        slidesOverlay.classList.remove('hidden');
        currentSlideIndex = 0;
        renderSlide();
      });
      champContent.querySelector('#btnSolo').addEventListener('click', () => {
        window.location.href = 'index.html';
      });
      champOverlay.classList.remove('hidden');
    }
    
    function setupRace(){
      // Azzeriamo la lastCompleteRun per dimenticare la run precedente
      lastCompleteRun = null;
    
      // Resetta il tempo mostrato
      finalTimeOutput.textContent = `‚è∞1'00"000'''`;
    
      // ==================================================
      // METEO: Rivalutazione all'inizio della gara
      // ==================================================
      let newWeatherState;
      if (!weatherState) {
        newWeatherState = chooseWeatherState(null);
      } else {
        newWeatherState = chooseWeatherState(weatherState);
      }
      showSnow = applyWeatherState(newWeatherState);
    
      const snowCanvas = document.getElementById('snowCanvas');
      if (showSnow) {
        snowCanvas.classList.remove('hidden');
        snowCanvas.width = canvas.width;
        snowCanvas.height = canvas.height;
        initSnow();
        updateSnow();
      } else {
        snowCanvas.classList.add('hidden');
      }
    
      currentTrack = createTrackForRace(raceNumber);
      resizeCanvas();
      drawTrack(currentTrack);
      bestTimes = [];
      updateLeaderboard();
      currentIndex = 0;
      attemptCount = 0;
      runNumber = 1;
      callParticipant();
    }
    
    /* =======================================
       Popup generico
    ======================================= */
    function showPopup(message, onOk){
      champContent.innerHTML = `
        <h2>Attention</h2>
        <p class="slide-content">${message}</p>
        <button class="nav-button">OK</button>
      `;
      champOverlay.classList.remove('hidden');
      champContent.querySelector('.nav-button').addEventListener('click', () => {
        champOverlay.classList.add('hidden');
        if(onOk) onOk();
        restoreStatusOutput();
      });
    }
    
    /* =======================================
       SLIDES INTRO & GESTIONE PLAYER
    ======================================= */
    slidesIntro = [
      {
        title:"Ski-Zag Championship!‚õ∑Ô∏è",
        content: `
          Enter the players!<br>
          <div id="playersInputContainer"></div>
          <button id="addPlayerBtn" style="margin-right:8px;">Add Player</button>
          <button id="removePlayerBtn">Remove Player</button>
        `
      },
      {
        title:"Race Info üèÅ",
        content: `
          There will be 3 distinct races (Giant, Special, SuperG). Each race has 2 runs (manches), and in each run every participant has 3 consecutive attempts.
        `
      },
      {
        title:"Top 5 Scoring ‚è∞",
        content: `
          At the end of each race, the top 5 best times are awarded points (9, 7, 5, 3, 1).
        `
      },
      {
        title:"Final VictoryüèÜ",
        content: `
          At the end of the 3rd race, whoever has the most points wins the championship! Have fun!!
        `
      }
    ];
    let draftParticipants = [];
    
    function renderSlide(){
      slidesOverlay.classList.remove('hidden');
      const slide = slidesIntro[currentSlideIndex];
      slidesContent.innerHTML = `
        <h2 class="slide-title">${slide.title}</h2>
        <p class="slide-content">${slide.content}</p>
        <div class="tutorial-dots"></div>
        <div class="slides-nav">
          <button class="nav-button" id="btnPrev">‚Üê</button>
          <button class="nav-button" id="btnStartNow">Start!</button>
          <button class="nav-button" id="btnNext">‚Üí</button>
        </div>
      `;
      const dotsC = slidesContent.querySelector('.tutorial-dots');
      slidesIntro.forEach((s, i) => {
        const d = document.createElement('div');
        d.className = "dot" + (i === currentSlideIndex ? " active" : "");
        d.addEventListener('click', () => {
          syncDraftParticipants();
          currentSlideIndex = i;
          renderSlide();
        });
        dotsC.appendChild(d);
      });
      const btnPrev = slidesContent.querySelector('#btnPrev');
      btnPrev.disabled = (currentSlideIndex === 0);
      btnPrev.addEventListener('click', () => {
        if(currentSlideIndex > 0){
          syncDraftParticipants();
          currentSlideIndex--;
          renderSlide();
        }
      });
      slidesContent.querySelector('#btnStartNow').addEventListener('click', () => {
        syncDraftParticipants();
        if(!checkDraftNames()) return;
        acceptDraftParticipants();
        startChampionship();
      });
      const btnNext = slidesContent.querySelector('#btnNext');
      btnNext.disabled = (currentSlideIndex === slidesIntro.length - 1);
      btnNext.addEventListener('click', () => {
        if(currentSlideIndex < slidesIntro.length - 1){
          syncDraftParticipants();
          currentSlideIndex++;
          renderSlide();
        }
      });
      if(currentSlideIndex === 0){
        renderPlayersInput();
      }
    }
    
    function renderPlayersInput(){
      const cont = slidesContent.querySelector('#playersInputContainer');
      cont.innerHTML = '';
      if(draftParticipants.length < 2){
        draftParticipants = ['', ''];
      }
      draftParticipants.forEach(n => {
        addPlayerField(cont, n);
      });
      slidesContent.querySelector('#addPlayerBtn').addEventListener('click', () => {
        syncDraftParticipants();
        if(draftParticipants.length < 6){
          draftParticipants.push('');
          renderSlide();
        } else {
          alert("Max 6 participants!");
        }
      });
      slidesContent.querySelector('#removePlayerBtn').addEventListener('click', () => {
        syncDraftParticipants();
        if(draftParticipants.length > 2){
          draftParticipants.pop();
          renderSlide();
        }
      });
    }
    
    function addPlayerField(container, def = ''){
      const d = document.createElement('div');
      d.innerHTML = `
        <input type="text" class="player-name-input"
         placeholder="Player name"
         style="margin-bottom:5px;width:100%;padding:6px;border-radius:6px;border:1px solid #ccc;"
         value="${def}"
        />
      `;
      container.appendChild(d);
    }
    
    function syncDraftParticipants(){
      const inputs = slidesContent.querySelectorAll('.player-name-input');
      if(inputs.length === 0) return;
      draftParticipants = [];
      inputs.forEach(inp => {
        const val = inp.value.trim();
        if(val) draftParticipants.push(val);
      });
    }
    
    function checkDraftNames(){
      if(draftParticipants.length < 2){
        alert("At least 2 participants!");
        return false;
      }
      if(draftParticipants.length > 6){
        alert("Max 6 participants!");
        return false;
      }
      const duplicates = draftParticipants.some((nm, idx) =>
        draftParticipants.indexOf(nm) !== idx
      );
      if(duplicates){
        alert("Names must be unique!");
        return false;
      }
      return true;
    }
    
    function acceptDraftParticipants(){
      participants = [...draftParticipants];
    }
    
    function startChampionship(){
      championScores = {};
      participants.forEach(p => {
        championScores[p] = 0; // Reset dei punti del campionato
        treeHits[p] = 0;       // Reset delle penalit√† accumulate
      });
      slidesOverlay.classList.add('hidden');
      raceNumber = 1;
      runNumber = 1;
      setupRace();
    }
    
    /* =======================================
       Gestione Quit
    ======================================= */
    document.getElementById('quit').addEventListener('click', () => {
      const confirmQuit = confirm("Are you sure you want to quit?");
      if (confirmQuit) {
        window.location.href = 'index.html'; // Reindirizza alla pagina iniziale
      }
    });
    
    /* =======================================
       Inizializzazione alla DOMContentLoaded
    ======================================= */
    document.addEventListener('DOMContentLoaded', () => {
      resizeCanvas();
      renderSlide();
      resetBlindMode();
    });
    
    /* =======================================
       Funzioni Helper
    ======================================= */
    function clearCanvas(){
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    }
    
    /* =======================================
       Popup generico
    ======================================= */
    // (Funzione gi√† definita sopra)
    
    /* =======================================
       SLIDES INTRO & GESTIONE PLAYER
    ======================================= */
    // (Funzioni gi√† definite sopra)
    
  </script>
</body>
</html>
